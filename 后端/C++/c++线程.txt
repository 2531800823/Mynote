
线程：
	1） 每个进程（执行的时候）都有一个主线程，是唯一的，执行一个进程后主线程自己就启动了
	2）主线程的寿命是跟着进程的（他俩相互的存在，有你就有我，有我就有你）
	3）用来执行代码的（理解成一条代码的执行道路）
	4）除了主线程外 我们可以写代码创建其他线程，其他线程走别的路，去不同的地方（就可以干不同的事情了）
	5）多线程（并发）并不是越多越好，每一个线程都需要一个独立的堆栈空间（消耗内存大概1M）线程之间的切换要保存很多中间状态（会耗费本该程序运行的时间）

实现并发的方法：1）通过多个进程实现（用很多线程启动很多程序）进程之间的通讯（管道，文件，消息队列，共享内存。不同电脑上用：socket通讯技术 ）~
		2）在单个进程中创建多个线程实现并发。自己写代码除了主线程之外的其他线程
		线程：每一个线程都有自己的运行路径，但是每一个进程中的所有线程都共享地址空间（共享内存）可以用全局变量、指针、引用在线程之间传递(使用多线程开销小于多进程)
		共享内存：写入数据的时候要分先后
	
	和进程比，线程优点：1）线程启动速度更快，更轻量级。
			2）系统资源开销更少，执行速度更快，比如共享内存这种通讯方式比任何其他的通讯方式都快
		缺点：1）使用有一定难度，要小心处理一致性的问题，主线程和子线程同时写入一块内存	
	
创建线程：Windows：CreateThread()，_beginthred()，_beginthredexe()
	linux:pthrea_create()
	还有和创建线程有关的，临界区、互斥量


线程运行的开始和结束：
	主线程从main开始执行，创建一个线程也应该从一个函数开始称之为初始函数 函数运行完毕就代表线程运行结束
	主线程执行完毕了，就代表整个进程执行完毕，如果子线程还在执行，进程结束子线程也会被强行终止。可以一直让主线程一直保持运行

头文件<thread> C++的！是一个标准库里面的类
	1）前面加了命名空间可以直接写 Thread 对象名(f)传递一个函数（就已经创建了线程，入口起点是从f开始的） 
	对象.join()是阻塞主线程，让主线程等待子线程执行完毕，他俩汇合，然后主线程在往下
	
	对象.detach() 分离，不汇合，各自执行各的，不由进程控制了，主线程一退出（子线程就转后台了），子线程就输出不到屏幕了。会导致线程失去我的控制（就不可以用join了否则异常）

	对象.joinable() 判断是否可以成功使用了join和detach。返回ture（可以用join和detach）和false就不能。有join和detach就要返回false了

其他创建线程方法：2）类  上面是函数，现在用类
		创建一个类，要重载一下 () 没参数  void operator()(){ 打印输出啥的操作 }   然后创建一个对象 a 再用thread 创建一个对象AA(a) 把类对象传递进去，就创建了一个线程也可以AA.上面的3个函数
	注意：主线程结束后，子线程还在进行时，主线程传递（引用）进对象的参数变量已经释放调用的就不明确了（不用引用就没太大问题）
	创建类对象的也被释放掉了，没关系 因为对象是被复制过去的（走的是拷贝构造）

	3）用lambda表达式，写法是这样也可以用，但是不明白原理呀
	auto 变量名 = [ ] {要做的操作 };然后后面的都一样，用thread 对象(传递前面的变量名)    auto是通用类型转换
	
	4）传递临时对象做线程参数
	定义几个变量 上面1）函数是没有参数的，有参数就是 thread 对象(函数名，参数1，参数2) 记得用引用的时候要加上const 。后面的都一样

	再类中写函数：在类外：先用类创建一个对象a，申请线程是：thread 对象(&类名::函数，&对象a)

要避免的陷阱detach：1）虽然函数接收是用&但是接收的并不是真的引用，还是做了一个复制（不是真引用）因为地址不一样。不然主线程结束被引用的就回收了，子线程也要崩溃，但是并没有
		传递指针接收的地址是一样的（创建线程用detach不推荐用引用，不可以用指针 绝对有问题）不可以用指针，但是要传递字符串 可以用 string &变量名接收（有引用记得加const），用string类模板接收就行了
		2）上面将字符串转成string 在还没有转的时候主线程就结束了，要在传递的时候就构造一个string对象 thread a(函数名，string(字符串))这样就保证了在线程中用肯定有效的对象
		3）thread 传参是整形 接收是类的时候要在传递的时候强制转换成类型，如：类名(整形参数名) 这样是临时对象构造的，不然会还没有构造呢 主线程就执行完了
			就是在创建线程传参的时候创建一个临时对象传参，用临时对象可以在主线程执行结束之前传递过去
	总结：若传递int这种简单类型建议直接用值传递（最好不要用引用）如果传递类对象，避免隐试类型转换，要在创建线程的这一行构建出临时对象来，然后在线程函数参数里用&接收（不用引用系统会多构造一次对象，浪费）
	       ：不建议使用detach 用join，这样就不存在局部变量失效到时线程对内存的非法引用问题

	线程ID的概念：id是一个数字，每一个线程实际上都对应着一个数字，不同的线程他的id必然不同。（可以用c++标准库函数获取）
	std::this_thread::get_id()来获取 可以直接打印出来

	临时对象构造时机抓捕：用了临时对象当参数传递的时候，就已经在主线程中构造完毕了，所以在创建线程的时候就不用担心结束还没有传递不进去了。函数接收要加&不然会在子线程在多执行一次copy构造
	
传递类对象：1） 因为线程创建接收的类需要加const 不可以修改，所以就有了，mutable这个 在类中定义成员前面加上他就可以修改成员的值了（修改了不会影响主线程的值，只是在子线程里改了）
	2）要影响主线程的值要用 std::ref 函数，使用 thread 对象(函数，std:: ref(类对象))用上这个函数以后，接收的时候就可以吧const删除了 mutable也可以不要了（这样在子线程改变的值就可以反馈到主线程了）.
	用过这个函数以后就是真正的引用了，地址啥的都一样（上面加了引用地址也不同）

智能指针：c++11并发与多线程p4-86.17

用成员函数指针做线程函数：
	在类中写一个函数，创建线程用类中函数当参数，先创建一个对象A，thread 对象(&A::函数名，A，（有参数就传参数）)
	 std:: ref(类对象)强制把对象的地址给子线程，join()可以使用，detach用肯定会出问题

p5
1）创建和等待多个线程：一个线程入口函数可以给多个线程用
	1）用vector容器来装thread  如：vector<thread> 对象名；用循环创建for(i=0;i<10;i++){ 对象.push_back(对象，i)在后面添加一个线程 }创建10个线程已经开始执行
		2）然后让主线程依次等待子线程执行结束，for(auto ite=对象.begin()创建一个迭代器，auto是通用类型符；ite!=对象.end();++ite){   ite->join();等待10都返回} 
	先创建的不一定比后创建的先执行结束，是乱的（跟操作系统对线程的调用机制有关）但是主线程是最后结束的，因为join()
	 把thread放进容器里管理，看起来像是thread数组，对大量线程进行管理很方便

2）数据共享分析：
		1）只读的数据：创建一个全局数据每一个线程都能读到数据，只读数据是安全稳定的，不用什么处理手段
		2）有读有写：有的线程写有的读，同时来，如果没有特别处理肯定会崩溃（不然就读不写，写不读，2个线程还不可以同时写，也不可以同时读）读写就是这么麻烦 
		3）其他案例： ~就是要有顺序啥的 就像买票不能两人买一个位子

3）共享数据的保护案例：
	网络游戏服务器，两个线程 一个收集命令 一个把命令写入消息队列中。这种用list容器合适
	在类中一个线程操作的时候另一个线程要等待（要按规矩来）
	要用互斥量解决
p6
互斥量：1）mutex 概念：保护共享数据，操作时把共享数据锁住（操作、解锁），其他想操作共享数据线程必须等待解锁   std：：mutex 对象； 创建一个互斥量
	就是一个类对象，理解成一把锁，多个线程用lock()函数来上锁，只有一个线程可以锁成功（成功lock函数返回，不成功就卡住一直去锁） 要小心，数据少了没有保护效果，多了影响效率

	2）用法：头文件<mutex>  在类中私有 创建互斥量 std::mutex 对象aa
		先lock()操作共享数据， 然后在unlock()解锁，成对使用（锁一次解一次）
	对象.lock();  要保护的代码   对象.unlock()

	3）为了防止忘记 unlock，引入了一个std：：lock_guard的类模板（你忘记了我给你unlock）
	可以直接取代lock和unlock，使用：std::lock_guard<std::mutex> 新建对象(上面对象aa )；上面那两个是包含中间 这个是直接在函数上面（局部作用域）

	4）死锁：1在北京等2一辈子，2在上海等1一辈子 ，一个互斥量是一把锁，至少有两个互斥量才可以产生 死锁
	是：线程1锁着锁1然后去 锁2的路上（他拿不到锁2），线程2锁着2去锁1路上（他拿不到锁1），就这样就死这里了
	解决方案：只要保证这两个互斥量上锁的顺序一样就行了

std::lock()函数模板: 能力 一次锁住两个或两个以上的互斥量（最少两个） 他就不存在上面死锁形成的原因，不会因为顺序不一样锁住
		要么两个都锁住，要么都没有锁住，1锁上了，另线程2再去锁1的时候已经锁住了先解锁然后再锁
	           锁住1个另一个没有锁成功就立即把已经锁住的解锁
	使用： std::lock(锁1，锁2)多个锁可以写多个 （这个锁是mutex 创建的互斥量对象）它两个顺序想怎么来就怎么来。 记 得  锁2（1 ）.unlock几个所就几个它

std::lock_guard的std：：adopt_lock参数：std::lock_guard<std::mutex> 新建对象(锁1 ) 上面有lock()的时候再有他就不行了，但是在加上一个参数 adopt_lock就行了，就可以代替unlock了
	使用：std::lock(锁1，锁2)；std::lock_guard<std::mutex> 新建对象(锁1，adopt_lock )；这样就不担心忘记unlock了   就不用写unlock了
			 std::lock_guard<std::mutex> 新建对象(锁2，adopt_lock )；这样就不担心忘记unlock了    就不用写unlock了
	adopt_lock是一个结构体对象，作用就是表示互斥量已经lock过了不需要在std::lock_guard<std::mutex>里面对对象再次lock了	
p7
unique_lock取代lock_guard：他也是一个类模板，比lock_guard灵活很多，效率差点，内存多用一点。常规使用他俩一样没区别，std::unique_lock<std::mutex> 新建对象(锁1 )就名字变了别的都一样
	参数：lock_guard支持的标记adopt_lock，unique_lock都支持，还有一些lock_guard不支持的，
	1）std::adopt_lock 表示这个互斥量以及lock了，（必须提前把它lock了）互斥量已经使用lock成功了才可以使用adopt_lock （用他必须提前加上锁）
	
小插曲：休息卡着	std::chrono::milliseconds 对象(20000); 是毫秒，1000毫秒=1s
      	 std::this_thread::sleep_for(对象)；休息多少秒，一直在这卡着 拿着锁一直在这个进程中	 下面有单位是秒
	
	2）std::try_to_lock  尝试用mutex的lock()去锁定mutex，但如果没有锁定成功，也会立即返回 不会阻塞在哪里（上面有个时间卡点来测试这个用的）
	用他不可以先用lock锁定，他自己也回去锁一下（可能会调用两次lock）不需要等待 先去干别的事，等那个好了以后在进行，
	用法：std::unique_lock<std::mutex> 新建对象(锁1，std::try_to_lock ) 尝试拿锁，if(对象.owns_lock()){ 拿到锁了，锁住 进行操作}  else{没有拿到锁 但是也没有被卡主 可以做点别的操作}

	3）std:：defer_lock  这个也是不可以自己先lock 和上面try_to_lock一样
	 初始化了一个没有加锁的mutex。std::unique_lock<std::mutex> 新建对象a(锁1，std::defwe_lock )先这个在对象.lock()加锁，不用自己解锁会给你解锁
用了std::defwe_lock成员函数可以新建对象a . 出来的成员函数
		1）lock() 就是用std::unique_lock<std::mutex> 新建对象a(锁1，std::defwe_lock )这个新建的对象来用 lock()
		2)unlock() 有加锁就要解锁（可以自动解锁）就是当有些代码不用共享的时候可以在unlock()下边处理，
		std::unique_lock<std::mutex> 新建对象(锁1，std::defwe_lock )；对象.lock()；共享数据 对象.unlock() 非共享数据，想处理共享了在lock上（下面全部都是共享就不用unlock了 会自动解锁）也可以加没必要
		3）try_to_lock 尝试给互斥量加锁，拿到锁返回ture 拿不到返回false，这个函数是不阻塞的  对象.try_to_lock()
		4) release()返回所管理的mutex对象指针，并释放所有权，这个unique_lock和mutex不再有联系  可以用 std::mutex *p=对象.release()   然后就要自己解锁了 p->unlock()
		
	有人把锁住的代码多少称为粒度，少就是细 效率高，多就是粗 效率低，粒度细可能会漏掉共享数据的保护，太粗影响效率，
	
	4）unique_lock所有权的传递 可以把对锁的权限转移给别人 但不能复制（就是用std::unique_lock<std::mutex> 对象(对象1)对象1装的是锁）可以用std::unique_lock<std::mutex>对象(std::move(对象1))
		现在就是对象1跟锁1没关系了，是对象和锁绑在一起了
	可以在类中创建一个函数，返回值是std::unique_lock<std::mutex>  函数名(){ std::unique_lock<std::mutex> 对象(锁)；return 对象 }创建函数对象返回  
		接收是std::unique_lock<std::mutex> 对象 =函数名()；这样子也可以拥有他的所有权
	所有权转移可以用 std::move 和 return std::unique_lock<std::mutex>返回

p8
单例共享数据分析、解决，call_once：
	面临的问题：需要我们在自己创建的线程里创建单例对象，这种线程可能不止2个
	注意：两个线程是1个函数入口，就会有两条路同时执行，两个同时执行单例就会出问题呀，单例是唯一的
双重检查（锁定）：if(a==1){ 费效率的代码 if(a==1) ... }这就是双重的，两个if语句条件一样的这种
	解决注意：在创建单例判断的时候 来一个双重检查 在中间创建一个 锁 ，就行了 （这个老师创建的单例不同c3的）vs线程里有  p8看完记得完善
	单例共享的数据就是返回的那个对象 ，在创建对象上面加锁 然后在来一个双重检查

创建单例：	1）私有化构造函数   class A
		2）定义一个静态成员变量 static A*  成员a;    然后初始化他 A* A::a=NULL;  在类外
		3)定义一个静态成员函数 返回的是指针     static A* f(){  if(a==NULL){a=new A(); }  return a;    }
		创建 A* 对象= A::f();    然后再用对象创建A* 对象2= A::f();  他们得到的到时同一个值 
		4）释放：在类中套一个类 class B{ ~B(){ if(A::a){deleta a; A::a=NULL; } } }    然后就也要在3）if语句里面加上  static B 对象2；含义就是 当程序结束的时候肯定会析构对象2，然后就该去执行前面写的析构了	

std::call_once()：函数模板，第1个是对象，第2个参数是一个函数名a  函数模板的功能是 保证a只被调用一次。他是具备互斥量的能力效率上比互斥量消耗的资源更少
		需要与std::once_flag（他是一个结构）这个标记结合使用
		和互斥量创建是一样的 是全局还是类成员都行 std::once_flag 对象a  这就是标记
	使用：	std::call_once(对象a,函数名)这个函数就是只调用一次了 当两个线程同时调用这个函数的时候，第2个调用的就要等第1个先调用的执行结束以后也不能执行这个语句，但是他要等待线程1执行结束后向下执行
		线程1 执行 函数a 线程2等 线程1执行完函数a 在向下执行（他不执行函数a） 老师说这个效率没有上面那个高

p9
条件变量std::condition_variable 、wait() 、 notify_one()：  std::condition_variable  是一个和条件相关的类，说白了就是等待一个条件达成（需要跟互斥量配合工作）用的时候生成一个条件变量对象 
			p6的那是10万的例子 出队的判断是否为空，效率有点低 用这个类模板改进一下
		实例：在私有类中定义一个条件对象（和互斥量写一起）  std::condition_variable 条件对象；
		1)条件对象.wait(huchi，[this]{  if(判断队列是否为空)return ture；return false });等待一个东西 ，参数1是 包含着线程的互斥量（mutex），参数2是 lambda表达式 里面写 等的是什么（也可以是函数，写法百度）
			如果lambda表达式返回的是false，那么wait将解锁，并堵塞到本行。一直堵塞到其他线程调用 notify_one()这个成员函数为止
			如果返回1 就继续往下面执行
		A）条件对象.wait(huchi)如果只有互斥对象一个参数，没有lambda表达式，就跟上面有返回false一样
			wait卡主的时候回把锁解开，不影响别的线程使用，不然不就是死锁了嘛。wait被唤醒以后一直尝试拿锁，如果获取不到还是会一直卡在这里（不断的获取）
		获取了就上锁，如果wait有第二个表达式，就判断lambda，
			a）如果是false就重复上边，解锁 沉睡，堵塞到本行，等待下一次唤醒
			b）如果返回ture 就继续往下执行了（此时互斥锁是锁着的）
			c）如果没有第二个参数 唤醒以后就相当于ture了 ，上面那个是直接沉睡相当于false了
		注意：因为是有10万 要记得沉睡的这个是死循环，会返回的，不然就执行1句			
		
		2）条件对象.notify_one() 在入队的时候（另一个线程）要执行结束要返回的时候 写上！ 要把wait唤醒了，你把它唤醒之后你的锁要尽快解开
			a）如果wait()现在不是在沉睡是在执行别的代码 还没睡呢  这个就没有效果了，只有在他睡的时候才有效果
			b）他只唤醒1个线程，当有条件对象.wait多个的时候 他只可以唤醒一个 一会这个一会另外的
		3）条件对象.notify_all() 可以一下唤醒多个wait  但是他们还是会卡住，因为要拿锁呀

p10
std::async、std::future创建后台任务并返回值    要包含头文件<future> 下面有future的其他函数成员
	1）std::async 是一个函数模板 启动一个异步任务，返回一个 std::future对象（他是一个类模板）
			自动创建一个线程并开始执行对应的线程入口函数 就是一个异步任务（返回上面future对象）
		实例：std::future<int> 对象a = std::async(线程函数)；int 是返回的类型 接收是整形（其他类型是其他的）
		std::future创建的对象a里面就含有线程入口函数所返回的结果（就是线程返回的结果 值）
		可以用 对象a.get()来获取 线程返回的值（结果）  有人称 std::future提供了一种访问异步操作结果的机制，不能马上得到结果，要等线程执行结束
			get() 要等线程结束了才会执行（不然就一直等待）等待线程结束返回结果，流程会卡在这里（只能调用一次，可以赋值给变量）
			是一个移动语义，只可以调用一次
		对象a.wait() 等待线程 本身不返回结果
	
下面p12有改正版的-->:	：
	2）std：：async传递一个类函数线程 和thread一样 类名 A;   async 对象a(&A::函数，&A,参数)第二个参数要加&不然就重新整一个对象了 
	注意：就算是不用get()和wait()也会等待一下（是主线程直接结束了 还会等待）

		1）std::launch::deferred 表示线程入口函数调用被延迟到std::future的get和wait函数调用时才执行！！
		使用：std::future<int> 对象a = std::async(std::launch::deferred，线程函数)；是在主线程里面执行子线程的
		a）如果没有get和wait就直接结束了 就跟没有线程一样（根本就没创建）
		b）加了get 执行 子线程和主线程的id是一样的。说明没有创建子线程 是在主线程里执行的 子线程里面的代码 
		延迟调用 一直到get和wait才开始执行，但是执行子线程的东西是主线程干的
		
		2）std::launch::async 在调用std::future<int> 对象a = std::async(std::launch::async，线程函数)；async的时候就开始创建线程了，强制创建一个线程
		上面那个是 主线程执行的（要有get和wait）  这个是创建子线程不需要他们两个就可以创建执行（这个用和不用没什么区别）系统默认用的就是他
	下面p12有改正版的	<--

std::packaged_task  也是一个类模板，他的模板参数是 各种可调用对象。用来包装线程
		使用：std::packaged_task<int(int)> 对象a(函数入口)；   <int是函数返回值(int是函数参数类型)>  他函数通过packaged_task包装起来
		a)   创建线程：std：：thread 对象1(std::ref(对象a),1) 1是传递进去的参数，线程直接开始执行，执行入口就是包装的函数
			用thread记得用 对象1.join()等待线程执行结束
		b)访问异步：std::future<int> 对象2= 对象a.get_future();  因为对象a是封装好的  可以直接使用。这样future对象2里就包含了入口函数的返回结果了	
			用 对象2.get() 打印值，（因为join等待了，他就不用等待了）
		c）他包装好以后也可以自己直接调用 如：对象a(传参数)  但是他是直接调用，相当于函数调用了，就没有线程之说了
	
	2）包装一个lambda表达式	std::packaged_task<int(int)> 对象a([ ] (int b){      线程函数要做的                  })； 就是把线程入口函数替换成了 这个  int b是形参
		和上面那个使用是一样的 ，就是把函数入口什么的 都变成了 [ ]( ){  }这个实现 
	
	3）生成容器：vector<std::packaged_task<int(int)>> 容器名；    就这就行了 ，他它当成类型放在容器中
		使用是吧对象移动到容器中，复制不太好： 容器名.push_back(std::move(对象a))对象a是封装好的  ，移动进去以后 对象a就是空的了就在容器里装着了 
		取出来是：定义一个std::packaged_task<int(int)> 对象b； auto ite=容器.begin();     对象b=std::move(*ite）要用移动 *ite是2级指针了（因为本身就是）auto 通用的方便什么类型都能搞
			移动过去了容器里还有呢，然后就把元素删除了，容器.rease(ite);  删除第一个元素(因为他指向的就是第一个元素) 迭代器失效（想用在重新指向）

std：：promise 也是一个类模板  可以在某个线程中给他赋值，在其他线程中取出用。他也是个上面那个一样都是封装好的
	a）可以线程参数 void f(str::promise<int>&q,int w ){   线程这操作什么运算啥的 }
	b）然后 创建 std::promise<int> 对象a;  创建一个线程函数 std::thread 对象1(f,std::ref(对象a)，10) f是函数名，后面两个都是实参,因为用的是引用所以就ref()
		对象1.join();等待   
	c）获取结果：std::future<int> 对象2=对象a.get_future();   然后打印 可以用变量 auto  c=对象2.get();  然后打印c
	总结：通过promise保存一个值，在将来某个时刻通过future绑定到promise上 然后得到上面的值

这样可以得到：不只这个类模板可以当形参 基本都可以 看自己的怎么使用了

p11
std::future的其他函数成员   std::future<int> 对象a=std::async(函数)；   记得头文件<future>

	1）wait_for 等待线程时间，参数是(std::chrono::seconds(1)，可以直接对象a.wait_for(10s)就是10秒。上面有毫米的单位 这是秒 .返回的是一个枚举类型，就是下面这个
					std::future_status  a=对象a.wait_for(std::chrono::seconds(1));  可以直接对象a.wait_for(10s)就是10秒
		2）std::future_status 是一个枚举类型  。std::future_status  a=对象a.wait_for(std::chrono::seconds(1));  等待1秒 哪个是毫秒为单位这个seconds是以秒为单位
		a）std::future_status：：timeout  是超时（线程还没有执行完毕） 可以用if判断 如果超时怎么做  if(a==std::future_status：：timeout){  怎么做？}
		b）std::future_status：：ready  表示线程成功返回	else if(a==std::future_status：：ready){  成功返回怎么做？ }
		c)std::future_status：：deferred  上面有 延迟的意思   else if(a==std::future_status：：deferred){  成功返回怎么做？ }  如果上面的async这个第一个参数加上 std::launch::deferred，则本条件成立

	2）std::shared_future  它也是一个类模板，因为future的get是移动语义（转移数据） 只可以使用一次 所以他就上场了 shared_future是复制
		可以在future他们下面加上这个 std::shared_future<int> 对象1(std::move(对象a))  也可以对象1(对象a.share())这两种写法一样。 对象a是future获取的值。记得用移动不然语法错误，执行完毕后 对象a就空了，值给了对象1
		也可以直接代替future  如：std::shared_future<int> 对象1(对象a.get_future())  对象a是线程返回的值直接使用，上面是经过future过滤了一下
			
		b)用 对象a.valid()函数判断值是否为空返回bool类型  有返回true 无返回false

3）原子操作 ：std::atomic  是一个类模板，是用来封装某个类型的值的
	1）原子操作概念引出范例：可以理解成一种：不需要互斥量加锁（无锁）的多线程并发变成方式。也可以理解成：是在多线程中 不会被打断的 程序执行片段，比互斥量更胜一筹
		互斥量的加锁一般是针对一个代码段（几行代码），而原子操作针对的一般都是一个变量，而不是一个代码段 
		原子操作：一般是指“不可分割的操作”这种操作要么完成，要么不完成，不会出现半完成状态（就是错误的值，要么是之前的之后的）要么执行完，要么没执行，不会出现中间状态

	2）std::atomic<int> a=0;  封装了一个 类型为int的 对象（值），是全局的可供线程来操作。可以向操作int变量 一样 来操作这个
		如：std::atomic<int> a=0; 定义全局  创建一个函数void f(){ for(循环1千万次){a++}}   这样创建两个线程来执行，最后打印  如果是普通的值（线程）会出错，加上原子就不会（要么执行要么不执行）不会被打断

	3）设置进程执行时间  写一个bool类型的 std::atomic<bool>a=false； void f(){  if(a==false){ 执行进程代码 }}  然后主线程可以等待用时间函数std::chrono::seconds(1) 在主线程给 a=true 然后就子线程该执行结束了
	
p12
4）原子操作 ：std::atomic 续谈： std::atomic<int> 名字=0
		也不是所有运算都支出原子操作，一般针对与== -- +=这几个常用的，其他的可能不支持

5）std：：async深入谈：
	1)std：：async参数详述，用来创建一个异步任务
		
		a）async一般不叫创建（虽然可以创建）叫创建一个异步任务，和thread最明显的不同是 async有时候并不创建新线程
		deferred	如：std::future<int> 对象a=std::async(std::launch::deferred,线程函数) 就这 有时候不创建线程，是主线程，延迟调用到对象.get和wait时才执行。 不调用就不执行，不创建新线程在主线程上
		async	std::future<int> 对象a=std::async(std::launch::async,线程函数)  强制异步任务，系统必须创建新线程，来运行线程函数（创建并立即执行）
		同时	std::future<int> 对象a=std::async(std::launch::deferred | std::launch::async,线程函数) 这个 | 的，意味着调用 std：：async可能是 第一种，也可能是第二种，系统会自己决定（异步或者同步）
		就直接一个线程函数 是和  同时  是一样的，可能是第一种，也可能是第二种。系统会自己决定是异步（async创建新线程）或者同步（deferred不创建新线程）
		系统怎样决定是异步还是同步
		b）std：：async和 std：：thread的区别
 			1）如果资源紧张 std：：thread创建线程可能会失败，整个程序就会报异常崩溃。想拿到他的返回值return，需要全局变量把值给全局 才可以得到（或者其他手段）但是也不容易
			2）std：：async 创建异步任务，有时候创建有时候不创建，用future 可以很容易拿到返回值 
		由于系统资源限制：std：：thread创建线程可能会失败。  std：：async一般不会崩溃，因为紧张的时候，不加额外调用它会 用谁调用了future的get语句的那个线程来执行

		c）std：：async 不确定性问题的解决：
			不加参数（只有线程函数）的调用，是让系统自行决定是否创建新线程。这么就不确定（就是系统没创建出来但是我按照的是系统创建出来的方式写的程序 ）
		用 p11的 1） std::future_status 对象a=wait_for(0s) 加一个判断 if(对象a==std::future_status::deferred ){执行里面代表，线程延迟了系统资源紧张了用了std::launch::deferred策略，
				然后cout<<对象a.get()<<endl; 就在对象a线程执行了，不创建新的了}
				else  if( std::future_status::ready 表示线程成功返回){这个是不延迟调用 然后做一定操作 }

p13
windows临界区、其他各种mutex互斥量
			Windows临界区和 互斥量是很相似的

要回windows编程一点，没基础先暂停





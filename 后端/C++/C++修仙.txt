头文件  #include<iostream>
using namespace std;  //有作用域的，要在全局用，在头文件下面，不写这个 输入输出就要加上 std::
#pragma warning(disable:4996)   把4996的警告去掉了

模板：
休息卡着	std::chrono::milliseconds 对象(20000); 是毫秒，1000毫秒=1s  <chrono> <thread>
      	 std::this_thread::sleep_for(对象)；休息多少秒，一直在这卡着，拿着锁一直在这个进程中		

输入：cin>>变量名； cin.get()	cin.getline(char * ， 个数)； getline(cin,string)这个可以让string读取一行
输出：cout<<变量名<<endl;  endl是换行 一行只能用一个 也可以用/n 效率比 endl 高哦
	

类型：一样  貌似不可以 long long型 
	小数默认是double类型的，如果想用float 记得在数字后面加一个f ！！！！！！！精度有限 不适合展示大型数字
	void 没有确定的大小，所以void* 什么类型的都可以返回 所有指针都可以往他身上转，但是使用的时候要强转

精度	控制cout 精度   加一个 cout<<fixed;  单词是固定的意思
	控制显示的精度setprecision(2)  控制到只有2个  头文件<iomanip>

头文件 <iomanip>
cout<<setw(8)<<"|"<<endl;  把后面的 | 后移8位置  可以用来制表
cout<<left    左对齐
cout<<setfill('_');   把里面那8个空格都填充成   _    默认是空格填充

循环 判断 ：一样

数组：一样 
	[ ] 的三种运算：1）声明的时候用是 数组变量，2）函数参数用 表示指针，3）地址+ [ ] 表示下标运算

结构体：	1、声明变量可以不用struct, 声明结构体变量的时候C语言要加上 例如：struct Node a ;  c++不用加struct 直接 Node a; c可以typedef来达到c++的效果
 	2、结构体内可以放函数，可以在结构体里写函数，c可以通过成员调用函数，创建一个函数指针 例如：void(*p)(); *p是指针名，传递结构体的时候记得把函数名赋值给*p，调用的时候a.p()就是函数的调用，c++可以直接调用函数 如：a.f(); f是函数名，
	3、结构体是一个特殊的类 先提一下，类的时候会讲解

memset	函数：  下面有用的 查一下  初始化 mamset（初始化的名字，0，len）初始化的变量  初始化成什么  初始化的大小
memcpy 函数:	 将一个空间的内存 转换给另外一个空间 使用: memcpy(被拷贝的空间指针，源指针空间，字节的个数 ) 不懂去百度或者MSDN在线去查
strcpy 函数：	如果是char 字符或字符串 可以用这个函数来拷贝 使用：strcpy(要拷贝的字符，源 ) c要加上头文件<string.h>

指针： 内存的操作:1、读 2、写 3、取地址 &
	申请空间 new 	例如：int *p=new int(类型要匹配) 也可以  new（4）申请数组要new int[5]就是申请5个数组 ； 直接定义一个指针接受，申请4个字节的空间，（和c有点区别 ）c申请数组是：int *p=(int *)malloc(5*sizeof(int));
初始化申请的函数：memset(指针，初始化的值，申请的大小 )，按照上面的例子就是   ，memset( p , 0 ，4*5 )初始化为0，申请的数字，大小就是20
	使用：直接用  *p=520; 赋值 也可以在申请的时候直接初始化，在 int后面 （初始化的值）可以直接赋值，例如：int* p= new int(520);，   cout<<*p<<endl; 读  
	释放空间 delete   例如：delete p; 就这么简单，delete+指针，数组释放是：delete[] p; 释放数组加上 [ ] ,指针要在 [ ]后面	c是malloc 和 free 不用多说

智能指针：头文件<memory>
	标准库提供的两种智能指针的区别在于管理底层指针的方法不同，shared_ptr允许多个指针指向同一个对象，unique_ptr则“独占”所指向的对象。标准库还定义了一种名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。


* 号的作用：1、在声明变量的时候 * 代表指针变量   如：int* p=NULL;        int a=10;    *P=&a;
	2、*+地址  表示地址操作符，两种操作，读和写,   *p 现在就是地址操作符，cout<<*p<<endl; 这是读，*p=520;这是写
	3、他也是一个乘号，也可以用来运算 ，如：20*21

引用变量：	和指针的思想差不多，但是效果不一样
	引用是已定义变量的别名（另一个名称） 用法完全一样，如同 c里面的 typedef 同理 他是给类型起别名 ，引用声明的时候必须初始化，同一个变量可以多个引用，可以起多个名字，地址都是一个地址
	也可以引用被引用的变量 他给他起名字 都是一个人，名字之上起名字  ，引用声明以后 就不能换了 ，再用就是重定义了
例如： int a =12；int& c=a; 声明变量 a 被c 引用，c是变量 a 的一引用，其他什么都一样	现在 &  是引用不是取地址
 c=13; cout<<a; a这时候就等于13 ，就是 a 的这个空间有两个名字 一个是 a 一个是c 他俩等级是一样的 和指针不同

常量的引用：
	常量的引用（12,12.1，'a'都是常量）定义常量的引用要加上 const  如：const int &a =12;  a就是12 了，而且a的值是不能修改的 就是给12 多了一个名字a

复合数据类型的引用：
	数组的引用：先是引用，然后是类型，注意优先级。 如：int a[10]; int(&p)[10]=a; 这样子引用，引用以后 p 的用法就和 a 的用法一样，p就是a 名字不一样 其他什么都一样
	二维数组的引用：类型很重要，要匹配 如：int a[2][3];  int (&p)[2][3]=a; 思路和一维数组一样，用法也一样
	结构体的引用： 把上面 int& a[]换成结构体名字，然后给他一个引用的名字，结构体就多了一个名字（这个没讲 是自行参悟的）
	指针的引用：  先定义一个指针，然后引用，如：int a=10;  int* p=&a;  定义了一个指针 p，开始引用 int * 先类型  然后再（&p1）引用 也可以不加() =要引用的 p; 就这样 int* (&p1)=p;  引用完 p1 的使用就和 p是一样的，p1就是p

引用与函数：
	引用做参数：在函数接收参数的（）里 用 int& a 接收，a就做了b 的引用，就把 a 也变成了和b 一样的东西，如果不用引用 int &a 是普通的 int a接收，就是把 b 的值 赋值给 a ,引用是 b 就是a，a 就是b
		用引用可以修改 b 里面的值，普通的当然不行，引用函数神奇的像指针一样，比指针好用，感觉速度快一点
交换两个函数传入的值：c是指针交换的，现在用引用来交换，感觉不用记笔记了，思维有点简单
	引用做返回值：类型很重要，返回定义的什么类型，就要定义什么引用类型，返回值用 引用！ return a; 返回的这个值，可以不用传参数在函数里定义，然后用引用返回值 返回，在主函数调用函数接收 int& b（接收的类型要是引用接收，注意类型）
		就得到了 子函数里的值，然后函数执行结束，把 a 释放掉了，b 在用的时候就没得了，运行结果还能打印出来，但是操作是非法的！！一定要避免，指不定哪天就出 BUG 了（但是这个用的也不少 问题不大）
引用与指针的区别：1、声明的时候就要初始化 指针不用， int *p; 但是有时候会让他指向空，不初始化也没事，引用必须要初始化
		2、引用初始化之后 不能再变其他空间了， 指针可以改变，而且是随便指，想指哪里指哪里
		3、 引用不占用空间，指针占空间
		4、引用效率更高，引用对空间是直接操作，指针是间接操作，效率可以忽略不计 没有特别大的区别
		5、引用更安全，指针可以偏移（指针更灵活，可以操作地址，c c++都可以使用，引用就只有c++）需要谁用谁
& 的3种作用: 1、声明变量的时候有它 就是代表引用
	    2、变量 前面加它 表示去地址
	    3、左右两边都是 数字的时候表示位运算  5&5 就表示位运算  	

函数：
 	参数默认值：在形参里直接给一个值就是默认值 如：void  f ( int a=10, char b ='A' ),这就是个默认值，全部指定，有多少参数就指定多少。也可以指定部分：从右向左连续指定，要么指定完，要么指定右边的
	调用：有默认值参数，传递实参会把默认值覆盖掉，可以不用传递实参数，没指定默认值的 一定要传递实参，因为部分指定默认值是从右到左，传值从左到右，左边的值没有默认值的都要传递
注意:函数声明的时候在 main上面生声明的时候写了默认值，在下面写函数定义时候就不要再写默认值了，会报错的

函数重载：
	函数名字相同，但是参数列表不同（参数类型不同 或 参数个数不同） 这两个条件 符合一个或者两个都符合 函数返回类型要一样 
c++可以让函数名字相同，但是参数必须不一样，有一点不同就行，不能一模一样，函数返回类型要一样 
	调用：系统根据参数的形式和个数，自动找到要调用的函数。可以实现你打印 整形，浮点（float 数字后面记得加f），字符，调用不同的重载函数，可以自己匹配
注意：形参中有默认参数值得 时候，"会导致" 实参传递得错误，分不清，如：int f(int a,int b=2) 函数重载 int f( int a) 这两个函数重载，实参 f( 5)就会报错，因为分不清是第一个还是第二个

预处理：
	防止头文件重复包含：#pragma noce（意思是这下面的东西只编译一次）优点：很好写 缺点：取决于编译器（有的支持，有点编译器就不行，移植性有点差）。 
 		c里面是#ifend 定义（如果没有定义可以在下面定义）#define 定义 { 然后他的用法 功能什么的 }   #endif（结尾）c这个的什么编译器都可以用，移植性好，这就是他们俩的区别
	
关键到了！！！！！

类：
理论：	面向对象和类的关系：面向对象是一种思想，类是一种语法，关系是语法是实现这个思想的基础 
定义：	具有相同属性和行为的对象集合是 类	相同属性 意思是数据成员 int a呀什么的，行为：理解为 函数 动态的 要工作要干活的东西
关键词	class 对象是类定义的名字（自己随意写的）	跟结构体一样，只不过一个是class 一个是struct都说结构体是类的一种特殊 
声明对象	在主函数声明对象用 类名 写一个变量，写的这么变量就是 对象！！，要申请一个指针类的对象，类名 * p =new 类名，要不申请空间就是一个指针变量，只有4个字节哦,普通对象是 栈区 用 . 指针是堆区 用->
调用	和结构体调用一样  类名 . 类成员（访问类成员的需要访问修饰符 public:），指针变量调用用 -> 记得释放哦  delete 对象
注意：类的所有成员都必须通过对象访问，除了静态成员（static）都不行。 类型 如  类名 对象 就具备空间，申请对象就会给你个空间 就可以调用了， 没有空间调用不了，指针要 new申请

访问修饰符：1、  public: 公有的（没有他会报错，无法访问私有成员）使类里面的成员对外可见，不仅仅是对 主函数所见，自定义函数也可见。  c++的结构体默认是 public: 的(也可以把它改成 private)，类默认的是 private
	   2、private: 私有的  如果类成员里面什么都不加 默认就是 private（私有的）加上它 就是一个显示的 没啥用
他俩可以单独给一个成员赋值 决定成员是 私有 还是 公有的 定义一个 一直到下一个访问修饰符为止 （下一个没有修饰符了）就到类结尾 都生效 。可以对函数做分类，如一些初始化的函数放在私有的什么的，有一种安全性在里面
	3、protected:  主函数不可见 自定义函数也不可见 ，其他类也不可见。子类可见可以使用（除了子类以外都有不可以使用，加友元也可以）
      private：私有的，只有本类可以使用（可以用友元），protected: 受保护的，只有本类 和子类可用（可以用友元），public: 公有的都可用。

4、1) 友元函数：关键字：friend  在类里面声明前加上 如：friend void f();（要把函数原型都声明上）这样 就算类是私有的、受保护的，f 函数也可以使用了，就是把 f( ) 函数声明成了 类的友元函数，类的私有成员都对友元函数可见了
  	       只要声明了友元函数，这个函数对这么类就相当于 public:  他们之间也没有什么秘密了，声明主函数也是 friend int main();
      2)友元类： 声明友元类也是和函数差不多，如：在类名1中  friend class 类名2；类2就成了类1的友元类了 	
1)) 申请友元以后，就算友元上面有 private 和 protected  也毫无影响，2)) 可以声明多个友元 3)) 缺点：破坏了类的封装性 不是迫不得已  没啥事别乱搞
 接口函数：在类里面创建  public：函数，在内可用 return 返回类里面的类型的值，也可以在创建一个同样的函数来修改值返回，在主函数（别的子函数里）可以调用这个类函数来得到值，修改，接收

成员函数：  构造函数主要是对类的成员变量初始化值的，析构函数是主要清理类的
1、构造函数：（系统有一个默认的构造函数，没啥用 有和没有都一样，自己写了系统的就消失了）自动调用，对数据成员给一个初始值。定义：类名( ) { 在里面可以给变量赋值int a=..,b=..(不用带类型，变量名直接赋值)} 这个是栈区对象，还有堆区的对象，
		就是指针  如：类名* 对象名；声明一个指针并不会自动调用函数（栈区对象会自动），因为他单单就是一个指针（要申请内存空间），要在 类名* 对象名=new 类名；这样子他才有内存，才会自动调用  
		1) 作用：对类的数据成员附一个值，跟单独在类里写一个初始化函数一样，更方便了。2) 执行时间：构造函数是对象创建的时候调用的（就是在主函数里面创建一个对象，在别的类，函数中 ）
	2、带参数的构造函数：必须要传递，不然对象就申请不下来，
	1)栈区 类名( 里面的参数，类型一样要对应上，这个里面也可以默认指定值，和普通函数指定值一样，有默认可以不用传递，也可以覆盖) { 函数内部，就可以用参数给类成员赋值了 }  定义了有参数的构造函数，那么一定要在创建对象的时候就要把参数传递进去 如： 类名 对象名（要传递的参数值）； 不传参数不写（）
	   2)堆区(指针) 也是在创建的时候传递，如：类名 *对象 = new 类名（传递的值），除了是指针不同 别的和栈区的用法一样，栈区有的堆区都有 
	3、多个构造函数构成重载： 函数重载就是参数列表不一样，根据上面的函数重载（记住默认值和重载会产生冲突）
	4、函数定义:可以在类内定义，也可以在类外定义，在类中定义函数声明就行，在类外函数 写一定要有！！ 类名作用域 如 类名 : : 类名( 参数) {  } 要注意！！还有一个就是 在类声明写了默认值，在外面定义就不要写默认值了 （上面函数重载有，别忘咯） 要在类中声明：类名（）
		  普通的成员函数也是这样子的，也是要加 “作用域的”要加在函数名字的前面。如：返回类型    类名：：函数名（参数）{ }  类中声明：返回类型 函数名（）
初始化与复制的区别：1、意义上：初始化时：一个对象或一个变量产生的时候就附带着值，伴随性质，如：int a=12;就是。赋值是：一个变量过对象产生之后任意时候都可以给一个值，随意性质，如：int b; b=12;这种
		2、宏观代码上：1)基本数据类型（int float char double） 作用相同  
			         2) 数组和结构体 : 数组：初始化：可以直接后面 {  } 进行初始化，如：int a[10]={1,2,3}; （[10]{1,2,3}）可以不用 = c可不行  赋值：声明完之后不可以用 {  } 了 要 一个一个的赋值（或者循环），如：a[0]=1,a[1]=2;  他俩形式不同 作用都是一样的，看哪个方便
					     结构体：初始化：也可以和数组一样用  { } 初始化多个值，赋值：就比较麻烦了，要 用 变量名 . 成员名 进行单个赋值。也是形式上的区别，使用的时候都一样 
			          3）引用和const : 引用：声明的时候就一定要进行初始化，不然就会报错， const : 他修饰的变量也要初始化（如果不初始化就不能进行赋值了）如：const int a=1;(这时候初始化，如果 const inta; a=1；这样是报错的)  const和引用只能进行初始化，不能进行赋值 
			        4）函数声明和定义：定义就是在调用前面定义写出来一个函数，声明是在调用后面定义的，就要在前面声明一下
只有类	1、初始化列表：（是类的一个属性）对数据成员进行初始化，和构造函数是：对构造函数 数据成员的赋值，初始化：直接在构造函数 ( ) 后面进行初始化 如：类名 ( ) : a( xx),b( oo) { } ,也可以传递参数初始化 如：类名(int c) : a=(c), b=(10){ }（要使用参数引用 &，不然是拷贝咯麻烦）（可以自定义初始化也可以传递参数）
		 赋值：赋值在构造函数里面赋值 如：类名 ( ){  在这里面赋值，a=xx; b=oo;  }
可以用		成员之间可以相互初始化，也可以相互赋值，“初始化的顺序是按照成员变量定义的顺序来执行的，不是初始化谁在前面就执行谁 要看成员定义的先后”，赋值的方式很多，还是根据自己用着那个方便顺手，适合那个，没有强调非要用哪个
	2、引用和const 初始化： 在类中用成员给引用初始化 如：在类中：int b; int& a 可以在构造函数用成员变量给引用初始化，类名( ) : a(b),然后a就是b 的引用，int &a（定义成员），可以通过构造函数初始化引用 类成员里的成员，可以引用主函数（子函数）的成员，
		要用传参数的方式，构造函数接收的时候用引用，先接受引用传进来的参数，然后再被a引用。如：类名(int& c):a(b | | c),b(c) { }  （这个样子更加稳定）
	const: 引用操作可以的他都行，但是引用 a( 不可以 const int e ), const e( 什么都可以,a,b,c都行，甚至自己输入一个值初始化)
	重载构造函数初始化也是那个参数对的上使用哪一个，跟重载函数一样（注意默认值）
	3、数组使用初始化列表：1)赋值：在构造函数里写一个  循环 来逐个给数组赋值，还有就是 上面写到的 memset函数 如：memset(首地址，赋值，要赋值的大小 )，int a[4]; memset(a | | &a[0],0(都赋值为0)，4*4（字节大小写少 不够，写多越界）)
			  2）初始化：在构造函数后面 类名（）：a( ){ }  就是这样 最好不要用，vc编译器不支持, vs也有警告，在构造函数里赋值好了，在函数里可以赋值
	4、结构体使用初始化列表：结构体可以写在类里面也可以在外面，写号结构体记得声明一下，在类中定义一个结构体变量（结构体定义在哪里都要写）。结构体不写类中就要写在类上面，不然不能用
		1）初始化：（可以在构造函数中直接用={ } 方式赋值）结构体也可以直接在主函数里面初始化，结构体名 变量= { ..，.. }（等于可以省略），然后到类中 初始化就是和主函数初始化一样 ，也可以当参数传递过去，构造函数接收 如： 类名（结构体名字 变量）：类中变量（传过来的变量）{  }
		 	 用初始化列表反而增加了复杂性，喜欢那个用哪个 ，构造函数什么的都可以！，

1、析构函数：是对象在释放的时候自动调用的一个函数（构造函数是创建对象时自动调用的一个函数，）析构函数和构造函数写法相同，就是在类名前面加了一个 ~   如：~类名( ) { }  这就是一个析构函数 
	没有重载，没有参数，一个类只有一个析构函数 ，默认析构函数和默认构造函数一样，默认的系统里面会有一个 什么都不做，和没有没啥区别，你创建了，系统的那个就没有了，   调用：对象声明周期结束，自动调用，
	1）局部对象：对象在局部变量中，从局部变量出来最后一个 } 就去执行析构函数，然后回来 在执行 }  执行完析构函数就带变这个对象的生命周期就结束了，主函数也是局部，但是在return 0;是就去执行析构函数了，因为一有 return 就代表函数结束了
	2）指针对象： 还记得怎么申请指针对象吧？（类名* 对象=new 类名）， 指针是在堆区的，不会自动释放，只有等到程序结束 指针的声明周期才结束 ，要主动释放才会调用析构函数 用 delete 主动释放，跟上面原理一样 就是一个要看到return或者 } ，
	      指针是看到delete 要不然就是等到程序结束，就算是指针对象在局部里也不行，return 也不行，只有程序结束和delete才会执行
	3）临时对象：创建：类名(); 有参数可以传参数 没有参数就这样写 就是临时对象（只有类名（）;），临时对象的作用域就在所在的哪一行，创建好走构造函数，然后直接回来再去析构函数，就在一行有效
1、malloc和free跟 new和delete的区别： 就是不能再对象上使用malloc和free 其他还都是可以的，区别：new会触发对象的构造函数，malloc不会，delete可以触发析构函数，free不行。可以new申请free释放哦 

this 指针：也是类里面相关的。 this指针是指向当前对象的，如：主函数定义一个对象传值，构造函数接收，类名（int a）{  然后成员变量也有a 分不清是哪个的时候就用 this 指针 ->a=a; this 是类类型的指针 可以直接指向（访问）成员变量a }
	1）作用：区分同名，指向当前对象的指针，可以通过this指针直接调用成员，没有对象就没有this指针，对象创建出来附带的有，而且多个对象有多个this指针，不可以在主函数里面用，this指针不是成员，是类成员的隐含函数（是就算类函数成员没有写参数，空( ) 系统也会默认传递一个this指针 ）所以可以在成员函数里用，
	2）this指针的作用域是在类的内部的函数里面起作用，只有在类里面的函数里，在函数外面也不能使用，因为this指针不是成员
	3）可以通过this指针得到对象的地址，因为this是指向这个对象的地址的，可以在类里写一个 类类型的返回值，直接 return this；返回对象的地址，也可以 return *this 返回对象，记得接收的时候也要 类类型，然后定义接收的这个指针就指向了对象，可以用接收的指针来掉用对象成员了 
	接收要用 类名指针  类名* 对象，返回值也要是 类名指针 

1、常函数：在类中有两个 一个 const常量成员，一个是常量函数。构造和析构函数不能是常函数    在变量前加一个 mutable 就可以开启上帝视角 在哪都可以改
	1）形式： 在返回类型 函数名字后面加 一个const { }   如：void f() const{ }
	2）特点：可以使用数据成员，不能修改数据成员，只能用 不能改（对成员函数的功能有更明确的限定。专门打印的函数加上这个very good）。 常函数内部的成员是可以修改的（就是自己在函数里面创建的 变量int a，float b,char c 啥的 ）
		常函数的this指针就变成了 const 类名* this了（在其他成员函数中都是 类名*this的）也是只能用不能改哦
		常对象只能调用常函数，不能调用普通函数，常对象就是在声明对象的时候在前面加了一个const 如：const 类名 对象名；可以把常对象叫做只读对象只可以调用常函数，不可以调用普通函数
	1、静态数据成员的使用：形式：静态数据成员 static int a;  ，静态函数成员 static void f( ){ };  静态 常量 整形 （这几个条件都满足才可以，整形不只是int哦）数据成员可以直接在类中进行初始化赋值，如：static const int a=10；这样是允许的 
		使用： 静态成员：不可以放在构造函数里初始化 可以放在函数里面 { 进行赋值 } ，也可以在类外进行初始化 如：类中 static int a；类外要：( 不可以加static) int 类名 ：：a=xx; 加作用域 ：：
		调用：类名作用域调用：cout<< 类名 ：：a<<endl; 可以这种方式调用， 然后就是通过对象调用 不用举例子了 简单。 
	2、静态函数的使用：和数据成员差不多，形式 如：static void f( ){}， 调用也有两种 类名作用域 类名：：f( )；对象调用 这么不用说了吧，自己思考一下，静态成员函数没有 this指针，还不可以调用成员函数和普通数据成员，可以使用静态成员和函数，因为可以直接用作用域使用本身，前面哪两个要求都是要跟对象关联的，他不用就不能用
		静态成员是一个类属性，是公有的，普通成员是私有的（普通的成员是每一个对象对会有一个空间，静态是无论多少个对象 访问的都是一个空间，只要是一个类就是一个静态）静态是在类创建了他就申请好空间了，普通的是创建对象的时候给的空间，而且他的生命周期是与程序共存亡了

1、拷贝构造 | 复制构造 copy： 1）形式:   类名(const 类名& a ) { }，和构造函数是重载关系 创建对象的时候只能调用一个
	2）调用：用一个对象去给新建的对象初始化，如：类名 对象1， 类名 对象2( 对象1)；把老对象当参数传递过去，然后就会调用到copy函数，对象1声明的时候就用的是普通的构造函数，对象2用的就是copy构造 没写就是默认，把对象1 的值一个一个赋值给对象2 一模一样哦
		还有就是 直接赋值对象也会直接进入copy构造里面的，如：类名 对象3=对象1；对象3 直接就会掉用copy函数 跳过构造，（直接用 对象赋值对象是不行的，对象3=对象1；是不可以的）因为构造函数是在对象创建的时候执行的，对象创建以后再用他俩赋值是不行的，
		还可以临时对象赋值给 新建对象也可以使用copy函数（本质和第二个一样，就是临时的对象）有的编译器会展现出临时对象的构造过程有的不会
		指针对象的copy：也是也上面一样 先新建一个对象 然后新建一个对象指针申请空间的时候他上个对象传递 如： 类名* 对象2 = new 类名( 对象1)；
	     调用2：用函数调用：定义一个函数 参数是  （类名 对象1）{ } 然后 调用的时候是参数是 函数名（老对象）；如：void f(类名  对象1){ } ，调用是 f( 老对象)；（然后就是老对象给你copy了，不想的话加&） 这样就可以是copy函数了
		，因为对象1 是局部对象，使用的时候传递参数是用老对象给他的一个初始化，这个过程就跟对象赋值是相似的一样的，对象1 的创建（申请空间）是调用的时候申请的
		函数返回： 用类类型做返回类型，接收肯定也是，接收的新建的对象=返回的对象，就相当于上面的对象赋值一样（应该可以理解吧）例如：类名 f(){ 创建一个对象（是局部的哦）类名 对象1；return 对象1  } 然后调用函数接收，类名 对象2 =f(); f 返回对象1 赋值给对象2 调用的就是copy构造函数了
	3）默认copy构造函数：（默认的里面会执行内容的）会逐个的复制非静态成员（成员的复制是浅复制）值，复制的是成员的值  就是把对象1成员得值 一点不差得赋值到对象2 例子：类名 对象2 = 对象1；如果手写 copy构造就会执行构造里面的 不是默认是什么都复制了，
		系统默认的是浅拷贝，默认构造函数给与的特性就是同一个类多个对象，内存排布是一样的 地址不同 系统默认拷贝的构造应该是  类名( const 类名& 对象1) { this->a=对象1.a }  this是新建对象的指针，区分一下，这就是系统默认的，写出来
		注意：（只有在指针的情况下）浅拷贝会出现重复释放空间！ 是因为 把对象1赋值给对象2的时候他们两个用的是同一个空间，所以在析构函数释放内存的时候两个对象都调用，多次释放就会出现程序崩溃，就有了下面的深拷贝
2、深拷贝：思路是：浅拷贝崩溃的原因是 两个对象使用的是同一个空间，但是调用了两次析构函数，释放了两次，深拷贝就是 给要拷贝的对象申请一个和被拷贝一模一样的空间，然后在析构函数释放的时候就各自释放各自的了，上面有系统默认的拷贝构造，深拷贝要自己写一个
	可以用memcpy函数进行拷贝，memcpy(对象2->成员，对象1->成员，字节大小 )，（上面有 这两个拷贝函数的讲解）或者 strcpy函数也可以，对象1要用引用传参数得到
	深拷贝在有指针成员的时候写有作用，没有指针写他没必要   如：类名 ( const 类名& 对象1){ 用memcpy 进行拷贝 或者 strcpy }（不是指针就用浅拷贝）这个是自己创建的构造

1、内联函数：不只是在类中存在，在类外也行，和常规的区别是（时间换空间） 内联是（空间换时间） 1、根据实际需要  2、看性价比
	常规函数的调用过程：普通函数的代码都在 内存中的代码区存着呢，当函数调用看到这个函数就跳进去执行函数，执行完毕在跳回来，有别的函数也是这样，来回跳跃+记录跳跃的位置== 一定的系统开销（时间+资源）
	1）内联函数：作用：用相同的代码替换调用（比常规函数稍快，代价是占用更多内存） 当函数调用就把内存中的代码给复制到函数声明这个位置，声明就没有了，函数代码复制过来代替了，就不要跳来跳去了就一直是往下执行了	 	
	2）声明方式： 在普通函数前面加上一个  inline 就是一个内联函数 如：inline void f() { }就是这样，如果函数需要声明的时候记得也要写上
	不是所有内联函数编译器都会把你当做内联函数 他也会把你当做常规函数（函数体过大，递归函数都是写了也没写，就直接给你当成常规函数了，不会报错）这都是编译器的特性，也不是所有编译器都实现吧，编译器也会把简单的常规编译成内联，主要看编译器的智能
	3）内联函数比宏的功能更强：因为宏是直接替换，很单纯；如：#define f(x) x*x  和 inline void f1(x){ 直接输出x*x }  在调用的时候  直接输出 f(2+3)用宏，这样他这么不智能就是单纯的替换，当然可以加（）把它包括起来，函数调用就直接 f(2+3) 比较智能一点，他俩也没有说谁好，看情况用谁
	4）类和内联函数：类内定义的常规函数都是内联函数，没加就是内联函数，加了更是内联函数了，没加是（隐式定义），加了是（显示定义），定义在类外（定义记得 ：：作用域），声明写类内的这种就是 加了才是 内联函数  不加就是常规。
	5）内联函数与多文件：通常内联函数 定义（不是声明） 都是写在头文件里面的（这个是编程的习惯）
		
运算符重载：1、类外：关键字：返回类型 operator + ( ) { } ,加号就是加法运算符，( )里面是参数列表，这么参数必须有一个类类型的参数（类类型参数记得加引用，不然就会调用拷贝构造，还有类返回值的时候），只能有两个参数，对象要放在最左边也可以在右边，也可以两边都是对象，可以函数重载。
	形式： 无返回值例子：  void operator +( 类名& 对象，int a) { 是写对象中那一个成员和int 相运算 } , 类名加&是防止拷贝构造，哪两个参数相加就传递哪两个，这个是+ 的  -（* / % 别的运算符） 就换一下符号就行了 
	调用：  对象 + a；因为是int 所以可以是常量 （参数类型要对应上）可以通过函数重载调用不同的运算 如：对象 +a 是一个，a+对象也是一个，可以两个对象
	有返回值的作用：可以进行连续运算（没有返回值就只能有两个参数）跟上面一样 就是有返回值了，可以连续相加相减什么的了 还是两个参数，计算好他们两个的和 以后返回 也可以直接返回，返回以后接收的值就是一个数字了，就可以任意的加减乘除了 
	如：定义：int operator+(类名& 对象，int a){ return (对象. 成员+a )} ，调用：对象+12-10； 把前两个传递进去，然后返回出来就是数字值了 就可以任意的计算相加了（就是系统调用了）
		可以函数重载 int operator+( int a,类名& 对象) { 没有返回值 就在里面计算以后输出，有就 return 对象 .成员+a }  这样就可以一直调用了，无限连加，也可以加（）进行优先级改变哦
	也可以在 operator+( ) { 这个里面进行别的运算}  因为符合条件都是去调用这个函数所以在里面干什么都可以（但是最好不要这样做，因为违背了他存在的本意）
	2、类内：是有局限应的， 只有：1、对象和基本类型，2、也可以对象和对象，因为对象是隐藏的 固定在左侧了，就有了很大的局限性
	    形式：1.在类内参数列表可以不用写 对象，直接写一个基本类型（因为在类别左侧默认有一个对象）
	返回就直接 return （传递a +  成员变量）；  返回类型 和上面一样 计算的什么类型返回值就是什么类型
	类内好还是类外：成员写在类内，非成员都行（有局限性）都是建议，主要看自己，1）左边不是对象就是类外，2）=  [ ]   ( )   ->   必须是类内，3）复合运算符通常是成员（>=、+= 这样的就是复合运算）>>=是位右移等于），
		4）改变对象状态的运算符，如递增递减 通常是成员（类内） 5）算术 关系 位运算 非成员（计算用的 一般写类外）
	3、运算符：有的运算符可以重载有的不行，必须是c++有效的运算符  像@就不是c++运算符，就不能重载
	可以重载： + - *  /  %  <<=  << >> >>=还有好多个慢慢来 百度搜吧
	不可以 ： （::）作用域、（ .*）当成员是指针的时候去成员的值是、（.）点 就不用说了、（? : ）三目运算符
	
二元运算符：理论;一元运算符是：一个操作数的运算符  -1（一元），2-1（二元），？：（三元）
	算术运算符：+  -  *  /  %		上面写的+法 这几个一样换换符号
	关系运算符：>=，<=，<，>，!=，==     关系运算和上面也一样，但是他们运算是判断对错的 如：1>=5（错 返回的值就是0，对返回1）其他都一样
	位运算：~ ，^ ，& ，|		也是一样 就是对象 的位运算，定义啥的都一样 就是里面的逻辑不一样，
	逻辑运算符：&&，|| 	 	这个也是 两边都是真就真，一个真也是真
	
一元运算符：+ - *（内存操作	） &（取地址），正号 负号   -对象  ，！（非 取反） ~ 作用也是一样
	类内：使用，还是和上面一样就是不用传递参数对象了（因为有this指针），函数内，计算是直接 成员前面加一个 符号（+-*&）
	类外： 还是和上面一样，就是传递一个对象 ，函数内 直接计算，对象名.成员 前面加一个 符号（+-*&）
都是一个形式，只是参数不同逻辑都一样，就是函数内部的样式不一样，

输出运算符：ostream,系统已经写好了普通的输入输出，写对象的：   cout<< 对象，这是 左边是输出的对象，右边是 普通对象，中间是<<运算符， 是不是和上面一样 例如：无返回值的 void operator<<(ostream& os,const 类名& 对象 ){ os<< 对象.成员 }（加引用是防止拷贝构造，加const 让程序更加严谨，因为不修改就加上他让程序更加严谨）
		有返回值的函数： 可以连续输出   cout<<对象<<对象返回类型就是 ostream& （加引用防止拷贝） return 返回一个ostream 定义的对象 ，这样就可以连续输入，返回的是一个对象有重新的调用了，然后在用返回的对象在传递输出
		因为默认左侧是 ostream 对象，所以不可以放在类内，可以把数据成员是 private 然后加友元给 运算符就可以使用了

输入运算符：istream  跟上面一样，就是运算符不同，这个是输入，要输入的对象.成员，一般数据成员都是私有的，所以都把输入输出定义成友元函数，要判断输入是否成功
	判断输入是否正确：在istream 函数里 有一个函数 fail( ) 来检测输入成功还是失败，成功返回0 失败是1，可以输入下一行写一个if（istream 定义的一个对象，对象.fail()）{  输入错误执行  常用的就是把输入要输入的成员回复到初始值，防止有的输入对，有的输入错}	
	可以整体连续进行输入输出了

赋值运算符重载：  +=  -=  *=  /=  *=  %=  <<=  >>=  ^=  &=  |=  建议类内，类外也行  （=   [ ]   ( )   -> ）他们是必须写在类内的，必须是成员 要在类内重载和上面加减一样 就是换成= 知道= 怎么用吧
	类外：赋值运算符区别是 名字就是换一个 符号  然后函数内  不直接返回了，先运算成员  例如：int operator+=(类名& 对象1，int  a )  { 对象1.成员=对象1.成员+a;  然后 return 对象1.成员 }，可以返回对象，
	int 换成 类名&这样(当然int 也可以连续运算整数)，return 对象1，可以连续运算（注意运算符优先性，从左到右，记得加( ) ），对象返回值值不可以直接打印，要是打印还要写上面的那个输出运算符，可以用对象.成员来打印，
	运算符灵活度很高，主要看自己怎么去写看需求
	类内： 和类外一样 就是把 第一个参数拿掉就行了，类内重载可以直接用所有成员，类外不可以用私有的 要加友元

下标运算符的重载:   [ ]  使用还是和上面的一样，可以接受里面传入的数据来打印 成员变量的第几个值，用 switch 实现 。必须放在类内声明用 如：int operator[ ](int a ){ switch(n) {case 0: return 成员1; 后面的就这样写 }  return -1； 输入大了返回错误 }
		返回值 加& 在 调用的时候可以赋其他的值， 如：对象 [1]=14; 就把类成员变量赋值成14了，  加&引用返回值就不可以是 -1 了  就要返回一个变量了。可以定义一个-1 ，但是定义了返回过来-1 还是会被14赋值，有点不严谨（还要多考虑），
		还有就是其他类型不能返回（说的是可以用指针返回实现，难呀）可以用void* 做返回值，但是打印什么的时候要用强制类型转换 *( 类型 *)对象 才可以使用 *是操作 括号里是 强制转换成 类型的指针
		写的时候同样是这种操作 如： *(int* ) 对象1 = 15；（并不推荐这样使用，还是&引用 才是下表运算的本旨逻辑 ）

递加 递减运算符：左++ 右++ 左-- 右--
	左++  --，类外： 式子还是上面那种老式子，返回值可以写 成员++返回 也可以写 +=1 返回，左--同理，类内：式子还是那个式子，就是不用传递对象用对象调用了 返回值 计算啥的和前面一样，左--同理
	右++  --，类外：他有两个参数，一个是对象（必须的）一个是整形（上面那个可没有哦）就把这个整形理解成一个标记（有这个就是右++，没有就是左） 实现：定义一个 变量 让成员等于变量，然后成员+=1，返回 变量（这样返回值不变，然后就曾1了）
		代码：int operator++(类名& 对象，int n ) { int a; a=对象.成员，对象.成员+=1；return a; } int n 存在的意义就是分辨是右++ 还是左++ 也可以把 n 换成a  那写a干嘛 竟浪费空间
		类内：还用说吗 换汤不换药
强制类型转换： 在变量前 加( ) 输入要转换的类型 这是 c里面的，c++也可以 强转的类型( 变量) 如：第一种：(int )a; 第二种 int(a);，用的时候就用前面的这个吧，c语言也通用，而且后面的也会对 对象有歧义
	强制转换对象：代码：在类内： operator int ( ) { return 成员1}； （换别的类型改int）想让他转换成成员1的类型返回成员1（operator 后面那个类型也要换成和成员一样的），想2就转换成2，直接函数重载一定义（可以每个类型都定义一遍哦），注意 他没有返回值，虽然没有返回值，但是可以返回一个值，这就是类型转换一个特殊的地方
		调用：(类型) 对象； （上面写的，用的是c语言也可以用的转换）也可以用第二种，但是不提倡（因为临时对象就像是这样的，容易产生歧义）
		注意点：1）没有返回的类型，但是要写返回值  2）没有参数  3）必须定义成类成员函数（不可以在类外的哦） 4）不能修改成员数据，应该定义成const （还记得怎么定义const 常函数吗？）operator 类型( ) const 
			 5）避免过度使用，（能少转换就少转换）因为可以直接用 对象.成员调用 不用走函数这一步了，效率更高一点
继承：
	写法： 新建一个类 在类名后面 写 ：public 要继承的类名，如：class 类1{ };   class 类2 ：public 类1，这样类2就继承了类1，public（是继承限定词，下面有介绍）
	继承的格式：1）基类叫父类（类1） 2）派生类叫子类（类2） 3）可以继承很多层（多继承） 原理都一样，在类2 后面 ，类3~就是多继承
		子类之间没有任何关联
	使用：子类 创建对象和普通的一样，子类可以调用父类的成员，当一个子类继承父类以后 父类的东西就全部属于子类了，就相当于成了子类的成员函数了 
		被继承以后 对 父类是没有任何影响的，还是该干嘛干嘛
	指针对象：和普通的指针创建对象一样 要 new 空间 使用用 ->
	
	继承的限定词：不写默认是private，和类中的访问修饰符一样
	1）public（在子类继承写的）继承之后 父类中成员是什么限定符，在子类中他就是什么限定符（父类怎么子类就是怎么样），在父类中 private是只有在本类中使用，protected 可以在子类和本类中使用，别的地方不行，public 哪里都可以用，主函数 自定义函数都可以	
	2） protected （在子类继承时候写的）继承之后 将父类中的 public 降级成 protected ，protected 和private是不变的，如果子类在被继承 子子类是 public 继承的 那么 子子类就不会因为 子类 降级
	3）private  （在子类继承时候写的）  继承之后 父类全部变成私有的了，用这个继承限定词 就不知道还继承干嘛 父类的你都不可以用！本来可以使的 结果给你降级成私有的了

继承的构造函数的调用顺序：1）无参数的：先执行父类的构造函数然后才是子类的构造函数，是一级一级调用的（从最最上面的向下调用构造函数）
		2）有参数的：子类创建对象时候没有构造函数参数时：如果父类有构造函数而且 有参数，那么子类就应该把自己的构造函数也写出来 ，因为父类有构造参数，所以应该传递参数 在哪里传递呢，在子类构造函数后面初始化的位置，
	如：父类构造 类名(int a){ } ,子类的构造 类名 (  )：父类 类名(要传递的值) { } 因为子类创建的对象没有参数所以 不用再创建的时候传递，但是父类有，就在这里传递，  如果父类没有参数实际是这样的 ：子类构造：类名( )：父类类名 { } （这个是默认的）
	如果有个祖父类 那么祖父类的 构造函数参数就是由父类 来传递，就不是子类的事了（不可以越界）
	 如果一个类中有多个构造函数：（就是构造函数重载）选择性调用，上面函数重载有讲（同理），是一级一级传递的，
			也可以用变量在构造函数里接收 然后在传递给父类，也可以从父类往祖父符类传（变量个具体数值都行）
继承的析构函数调用顺序：是从子类向上调用的，构造是总父类向下调用 （正好相反）

覆盖：父类和子类出现同名成员时，C++采用一种处理方式叫覆盖，
	1）数据成员同名：子类和父类都有一个成员相同 使用的时候用的是子类的（父类的直接被覆盖了，不是屏蔽）可以在子类中使用父类 用后面这个方式  父类类名：：成员，也可以主函数中调用父类中的值，对象1（子类申请的）. 父类类名.父类成员
	2）函数成员同名：子类覆盖父类 和数据成员一样，父类和子类没有函数重载关系（不可以有）只要是名字相同！就会覆盖（不管有没有参数 参数一不一样），可以用类名作用域   ：：来区分 例如：liu : : Cli.f( ); liu是子类创建的对象，Cli是父类 f()是函数成员
	3）友元函数：不可以继承，写在那个里面就是那个里面的 （你父亲的朋友不是你的朋友）
	4）静态成员 ：是公有的，不管是父类还是子类 都可以使用静态成员，无论在哪一个类创建都是公有的 大家都可以用

多态：是一种泛型编程思想：1）同样的代码实现不同的功能 2）宏观的体现是 父类的指针调用子类的函数
虚函数：	是实现这个思想的语法基础（多态思想）跟类和面向对象的关系是一样的
		父类的指针指向子类的空间：实现父类的指针调用子类的成员 代码： 父类名* 指针对象= new 子类名；         平常的创建指针的类型和空间的类型不一样 会报错，就malloc强转拿一下，这个不会？
		申请了也可以指向子类，但是调用的时候还是只可以调用自己的空间（指针如何调用空间是取决于创建的类型的 ，如 ：int 的就只可以调用4个字节）
	虚函数： 关键字： virtual   把它放在函数前面 函数就变成了虚函数，如果父类的函数定义成了虚函数，然后用上面申请的指针调用父类的虚函数，就可以调用子类的这个（必须名字相同）函数，如果函数没有virtual没有 就调用父类里面的 有就是子类的
		形式：子类函数要和父类这个函数名字要一样，如果不一样，父类还是调用自己本身，一个父类有多个子类，申请的new 指向的是哪个就调用那个，前提函数名字要一样
		         多态必须是指针，栈区的不行哦
		特点：1）重写：概念是针对虚函数的 就是子类去重写父类，所以父类调用才是子类的结果，把父类给重写了 数据成员没有效果 虚函数（只有函数）
			        子类函数重写以后 默认就是虚函数了 可以加virtual，也可以不加（默认的有）可以得出结论，如果在继承一个子子类，子类就可以直接调用子子类的函数了，因为他是虚函数，子子类一继承 同名函数也是虚函数了，就可以用子类指针调用子子类了
		           2）返回值和参数必须是一摸一样的：（不然还是调用父类的），函数体没有规定，随意写，返回值不一样的话 就直接报错 也不调用父类了。。
			只有一种情况返回值可以相同  是协变：（当前的类的 引用、指针、对象是可以的）就是父类返回自己的类型，子类也返回自己的类型（记得加&）返回的是 return *this  这种情况称为协变
		          3）不可以是内联函数  就算是写了 也没什么效果 没什么用，构造函数也不能是虚函数，因为构造函数是内联函数不能是其他类型的

	虚表：1）虚函数的覆盖原理：1）当编译器编译到父类中 发现有虚函数就把它放在虚表中（普通的不放），当执行 父类* 指针对象 =new 子类  这个过程的时候 就会检测 子类中的虚函数名字是否和虚表中有一样的，如果有一样的就把子类中的这个函数覆盖掉父类的函数，
				当用指针使用的时候，发现调用的是一个虚函数，然后就去虚表里面找到对应的位置调用函数指针，通过函数指针就调用了子类的这个虚函数
			2）如果指针使用发现是虚函数进入虚表以后没有一样的名字，就调用函数找到自己本身
			3）每一个指针对象 都有一个自己的虚表跟别的虚表是不冲突的
	          2）取虚表地址以及内容：1）存在位置是：对象空间最开始的四个字节，就是虚表（虚函数列表）的地址，叫做虚指针
				2）去    * 指针对象名 这就是使用整个类空间，然后要强转一下，因为取4个直接的空间（虚标的地址是前4个），就强转成int类型的   *(int *)指针对象名	 
			。强制转换把类类型换成了 int* 数组，(int *)*(int *)指针对象名。然后在取int* 数组的首地址 *（(int *)*(int *)指针对象名+0），+1就是去下一个虚函数的地址了，虚表结尾也有一个元素 
				上面的到了函数地址，然后去调用这个函数地址，用通过typedef 定义一个void的指针，typedef void (*p)( );  然后使用的时候就是 ((p)*((int *)*(int *)指针对象名+0) ( )); 把 上面写的 转成p 然后后面加一个小括号( ) 括号前就是函数调用	
		取地址内容理解用，知道它的原理就行
	           3）虚析构：构造函数不可以是虚函数，析构可以（作用非常关键）
		普通：普通申请一个父类指针指向子类，在释放的时候只调用 父类的析构函数，不调用子类的，只用用虚析构才可以把他俩的的析构函数都调用 
		虚： 在父类的析构函数前面加上 virtual ，子类不加也没事，已经默认加上了，加上以后 申请父类空间 释放的时候，子类的虚构也调用了，如果申请的指针类型是子子类 调用释放的时候3个都调用析构
		delete：在使用它的时候 是哪个类型的指针 就调用谁的析构函数，可以强转 释放别的，如：delete  Cp; Cp 是父类的对象现在释放调用的就是父类的析构，在强制转换一下：delete (子类名 *)Cp;现在就调用子类的析构函数了，然后在调用父类的析构函数（可以不用虚析构就调用两个的析构），还是释放的这个指针
			如果强转成一个 跟释放指针没有关系的类 那就只调用 强转的这个类的析构函数，当delete 释放空间 指针是什么类型 他就调用谁的析构函数（即使没有关系）
			虽然调用不相干的析构函数，但是还是会释放指针指向的那个空间
		特点：1）指针是谁的类型就调用谁的析构函数。2）不管调用谁的谁的析构函数 这块空间还是被释放掉了的（对象空间不会被泄露）但是对象成员申请的空间 有可能会被泄露（因为析构函数就是来释放的嘛，不用他了就没法释放了）

	纯虚函数：形式 在函数后面加一个=0 如：virtual void f( ) =0; 没有花括号的那些内容，
	           当类中有纯虚函数的时候 是不可以直接定义对象的（不能创建对象）没有函数主体 调用也调用不了，有纯虚函数的类，必须用子类重写（上面有重写）纯虚函数，才能实例化对象，
	          有纯虚函数的类不可以创建对象，如果子类继承了纯虚函数的类没有实现这个纯虚函数 那么子类也不可以创建对象了（因为继承过来以后子类也有一个纯虚函数，不实现不能创建对象，也可以用子子类创建实现，必须子类重写才可以创建对象）
		特点：1）没有函数实现。2）用一个子类去继承他，然后并实现它，就可以定义对象了	3）有纯虚函数就是变成了抽象类
		接口类：全都是纯虚函数（上面可以有数据成员 普通函数 ）还有虚析构（也可以是纯虚） 可以用来搭建框架，做游戏，
	
	虚继承：有多继承了，虚继承才有存在的意义，父类就变成了虚基类
		1）多继承：有多个父类的子类就是多继承，如 class 类名 :  父类1  ,  父类2 ，父类3  这种就是多继承 用 逗号隔开（在每个父类前面加上作用符public 或者哪两个）。他的父类还可以继承别的
		2）虚继承就是来解决多继承的问题的： 如 A B C D,B和C分别继承了A，然后D又多继承了B、C。然后D 就同时拥有了他们3个的成员，因为B C里都有A的元素a 然后D继承的时候就有了两个a, 调用的时候系统也不知道是哪一个
		虚继承就是解决上面那种问题的
		形式：在继承父类的 public 前面写virtual，B、C都要加上，当B C都是虚继承了A ，然后D继承了B C就没有问题了，像B 虚继承A 他的成员是不进行复制的（继承是复制的）a还是在A里面 B只是继承过来一个 使用权，没有把东西拿过来当成自己的。C和B一样
		        继承到D了呢  D就也只有一个使用权，a 也不属于D,就不会造成访问不明确了

联编：概念：就是将模块或者函数合并在一起生成可执行代码的处理过程，（函数调用），这个过程就叫做联编，按照联编所进行的时间（阶段）不同，可分为两种不同的联编方法 ：静态联编和动态联编。动态联编有不确定性，就比如输入一个数，调用父类函数还是子类函数
	当程序执行碰到函数然后去函数体里执行函数体 这个过程就是联编
	静态联编：编译的时候就确定了（适用于一切的基本情况）
	动态联编：执行的时候（在c++中是针对多态的）就是父类指针指向子类，调用函数的时候（不是所有多态都是动态）是动态进行修改的才是动态联编

单例模式： 意思是：一个类只能创建一个对象
	第1）步，让构造函数成为私有的，或者受保护的就不可以创建了。在构造函数上面写一个 private 或者 protected，就都是对外不可见了
	2）通过静态成员函数申请对象空间，并返回地址（不能从外部调用就从内部调用，静态函数可以用作用域调用）因为构造函数是私有的只可以在里面创建，如：static 类名* 函数名( ){ return new 类名；} 返回一个类类型的指针，返回是创建一个对象接收是：类名 *对象名=类名：：函数名( )。现在还是可以随便申请对象
	3）定义一个静态标记，记录对象的个数，并控制。在上面的那个静态函数中控制，先定义一个静态成员，在类外初始化为1，然后在函数中判断 if(1==a)返回上面那个，然后记得把 a在等于0（放前面），else 返回空 return NULL; 这样就只可以创建一个了  ，可以再外面申请的时候判断等于NULL 就别进行操作了
	就算delete释放掉第一个申请的对象 ，第二个还是指向空的，所以还要在进行改进
	第4）步，析构函数，将标记清空，以达到重复申请对象的目的，就是在析构函数中，他 a重新赋值成a  释放掉就执行析构变成1，又可以申请了
	1、不能被继承的类：当构造函数是私有的时候他就不能继承了，继承成功以后不可以实例化对象的（创建对象）运行的时候才会报错，因为实例化的时候调用了父类的构造函数，只实现单例模式，构造函数是private 和 protected都是可以的

异常： 异常是认为定义的一种状况，不知道具体类型catch（...）
	函数：abort ( ) 异常终止的一个函数，他一执行程序就直接崩溃了，看看吧他放在那里 什么情况让程序崩溃   c语言的这个函数的头文件是 #include<stdlib.h>，c++的是#include<cstdlib>  把 .h 去掉了换成 在前面加 c （C语言的头文件基本都是这样转成c++）。c++不加头文件也没事 ，为了保险
	try throw catch  使用：try { 函数调用写在这里面 }  throw 抛出值（和return类似）他抛出以后用 catch(接收抛出的值 ){ 处理抛出的值，可以打印可以。。。}   try 检测异常的功能，throw 抛出是在别的函数中进行的，catch参数接收，然后再函数体里处理，可以函数重载，多写几种处理情况
	       也可以在catch函数中在嵌套一个 try catch，记得调用函数（就不能跟上级一样了，不然就是死循环了，要让实参做点变化吧），接收   
	   当接收是没有类型匹配或不确定类型的时候 可以写一个重载函数在接收  如：catch ( ... )参数是... { 在这里面 定义打印或者什么}
	可以异常抛出对象，try { 调用函数传递的是对象 }  和函数一样，就是形参变了，调用类型也变了 ，基本用法还是一样

内部类（嵌套类）：就是在类里面在创建一个类（也可以设置公有私有）
	类2在类1中嵌套，再类2中（虽然是内部类） 还是不可以直接调用类1的成员， 如果要调用类1 成员，就要在类2 创建一个对象，在类1调用类2 也要创建一个对象，
		在主函数中，申请一个类1 对象 . 类1中定义的类2对象 . 类2函数成员或数据成员
	内部类不可以直接调用外部类，要在内部类申请一个外部类的对象，用对象调用，要调用内部类 也要在外部类创建一个内部类的对象
	上面哪几种是当在主函数中定义对象调用是，给类1赋值 但是通过类2打印出来的值不会改变是因为，类2在函数中调用类1 的成员是新定义的对象，在主函数中也是新定义的对象，两个对象不相干 所以就不能改变值（可以通过指针）
	内部类就不要创建对象了，直接创建一个 外部类的指针，用内部类的构造函数给这个指针初始化，就收参数 外部指针类型，在外部类的时候创建对象后 用构造函数初始化把this指针传进去，如：B a;创建一个内部对象a  A( ):a(this){};传递   内部接收是 A* p；然后构造接收赋值：B(A* p1 ):p(p1){}
	   在类2中定义一个类1的指针成员，用构造函数 传递参数来给指针初始化，因为构造函数有参数了，在类1中创建类2对象的时候要把this指针传进去，直接创建的时候传递会报错的，要通过构造函数初始化来传递 如： 在类1中： 类2 对象a； 类1( ) : a(this) { } 把对象a赋值成this指针（如果上面写了构造函数，就把这个初始化写在上面）

类型转换： 旧式类型转换： (type) value、(double)12; c++又多一个 type (value)
	新式类型转换：新式转换分的更细了。
	1）static_cast：目标类型可以和当前的表达式可以进行隐试转换（就是要转换的类型可以和谁转换他俩可以相互指就是隐试转换）的时候才是合法的（父类子类之间转换没关系，如果有一个不相干的类进行转换，就报错了） 这样比旧类型转换安全
		形式 static_cast<>( ) <要转换成什么类型>（谁转换） 这个更好用（会帮我们进行检测）
	2）const_cast：这个转换是去掉 const 这个属性的 只有是两个类型一样的时候才是合法的，如：const CA *p;   CA*p1=const_cast<CA*>(p);必须带括号  这样才合法，就是把const CA*p 转换成CA*p。作用就是把const 去掉，实现别的转换不可以哦
		如果旧式的不会有错误那就可以用旧式，没有硬性要求 看哪个好用用哪个
	3）dynamic_cast： 特点：<a>(b ) 1）a的类型是继承b的，2）a的类型是b的类型（是一样的就不用转换了，但是这个运算符允许一样）3）a和b是相互继承（不能说相互继承）就是a是父类b是子类，b是父类a是子类，
		针对有继承关系	父子类指针相互转换的运算法，或自己转自己。形式：dynamic_cast<父类*> (子类对象) 。也可以父类对象 转换成子类*（必须是多态的情况，有虚函数 子类重写）在可以进行反过来转换，本身转本身就没有意义了
	4）reinterpret_cast:运算符用于天生危险的类型转换，针对特殊的 可能会出错的这种。形式和上面一样
	注意：	这种转换适用于依赖实现的底层编程技术，代码不可移植。例如：不同的系统可能已不同的顺序存储多字节数据中的字节
	 	相互转换时，空间一定要够用，否则不行，  函数指针和数据指针不能相互转换
	前两种最常用，一般用第一个！
	新和旧的区别：1）查相关资教，描述，新式转换，编译器更容易识别，更友好。2）对于不合理的转换，会有有限制，或者说在程序早起就避免程序员要饭的错误，而旧的转完就不管了
		           3）类型转换，能不用就不用，不要自己想用就用，明明可以更直观的对数据进行操作，就不要非得强转操作。4）书上最后说，如果你受不了这个限制就是用C语言吧，哈哈哈，作者可能遇到让他无奈的学员了

函数模板：
	在函数重载上更进一步，用同样的一个代码实现不同的功能（模板是泛性的一种重要的思想，stl就是利用模板实现的一个具体实例）
	形式：template<typename T>（<class T>也是可以的，写那个都可以）可以给参数起一个名字，T就是名字，通用于所有类型，int float double char 都可以使用，对重载函数太方便了
	        可以有多个参数，如：template<typename T,class Y>中间是，隔开，可以混着用class和typename，定义了就要传递参数（要指定类型）
	作用域：仅对下面挨着的代码段有效，再往下就没用了，用还要重新定义
	例如： template<typename T>void Swap(T &, T &);//函数声明  |||  template<typename T>;//模板头  void  Swap(T &a,T&b){~~ } 

	具体化：具体到单个的一个类型去处理。把特殊的拿出来单独处理，直接在后面写函数 
	形式：template<>void f<>( ){}  f的<>是要处理的类型  （）是传递的类型（个别记得加&）如：template<>void f<int>(int& a){ }
	具体化的优先级是优先上面的那种模板的，传递普通的就还走普通的，每一种类型都可以单独处理

	实例化：生成指定的函数定义
	形式：template void f<int >(int a); 没有函数体，就是传递参数就算不是整形（自行定义的）也要把整形的生成出来（就没有了？）

类模板：也是写在类的上面，作用域懂！ 如: template<typename T> 在类中就可以直接写成  T  a；了 类型可以自动转换，可以构造函数接受的时候用，构造函数也可以不用传参数，但是函数就不行了
	在类创建对象是 要写上 T 要转换的类型，传递一个T的参数 如： 类名 <int > 对象(10);      上面的T a 就变成了 int a了。<int >叫做模板参数列表
	可以给模板一个默认值！（只有类模板可以有默认值，函数不行） 如：template<typename T=int>,有默认值以后 创建对象的时候就可以不用写类型了 但是一定要有 <> ，如果传递了就会把默认值覆盖掉。多个默认值是从右到左传递默认值的和默认函数一样
	有两个参数定义模板参数列表的时候就要有两个参数， templata<typename T,typrname Y>  。 类名<int,char> 对象（参数）；
	指针对象：类名<int ,char>* 对象=new  类名<int,char>   每出现一个类名就要有一个<>每次都要一样，只要在类外碰见 类名就要加上<>
	类外实现的函数模板的写法： 如果有函数在类外声明了，就要在函数上面写一个template<typename T>（这时候写就不能默认值了，因为下面是函数不是类）因为他的作用域只在类中，函数要写 void 类名<T,Y>::f( ){ } ，如果不加上面那个东西是：void 类名<int,char>：：f( ){  }     <>要和定义对象的时候一样

继承模板：父类有模板就有父类类名就写上<>
	通过子类模板参数列表传递：子类也有模板，因为父类<>传递的时候已经是固定类型了，所以应该吧固定的类型写成通用的，就把父类类名<>写成子类定义的。如：子类定义：template<typename x,typename z>, 继承时候写：class 子类 ：public 父类<x,z>这样写父类的类型相对来说就成了动态了
			传递：通过子类创建对象的时候传递。如：子类 <int ，char> 对象； 就把x和z都换成了这两个，然后传递给父类
	注意：除了 子类构造函数写父类传参数的时候可以不写(也可以写上)<> 别的地方出现父类就都要写上<>

多态的模板：父类的列表由子类传递，
	形式：定义一个父类指向子类的指针：父类<> 指针=new 子类<>。 <>的类型自己定义，父类的和子类的要一样因为父类的是和上面子类有两个关联的（如果一个有关联就传递一个，当然子类上定义了几个子类就传几个 ），父类使用的类型（传递的类型）要和子类传递的类型对应上，上面有关于继承写<>的方法
	如果子类没有定义template<typename T>  那么 定义多条的时候 new 子类 就不用传递模板了，因为父类的什么都是固定的形式类型
	注意：类型一定要对应上，不然会报错的

类型是类的模板：把类当做模板 别的都一样就是把 <int >换成<定义的类名>  把一个类当类型  
		传递：有参数就是用 类名创建一个对象 然后把对象传递进去，接收是 类类型引用
	如果传递的类也是一个模板类：记得把所有出现 类名的地方传递上类型，就算是当做函数接收引用的时候也要写上



								！！！！！！！！！完结！！！！！！！！！
	
		




















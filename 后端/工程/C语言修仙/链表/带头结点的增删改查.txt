#include<stdio.h>
#include<stdlib.h>

typedef struct Node {    //结构体
	int a;//数据域
	struct Node* next;//指针域
}STU;

STU* g_pHead = NULL;  //定义一个全局的头指针
STU* g_pEnd = NULL;  //定义一个全局的尾指针

//空头链表初始化
void  InitListHead();
STU* CreateNode(int a);//创建一个节点
void AddLIstTail(int a); //尾添加
void AddListHead(int a);//头添加
void printfList();// 打印
STU* SelectNode(int a);//查找指定节点位置返回节点地址
void AddListRand(int Index, int a);//任意位置添加
void Gaibian(int Index,int a);//在哪里改这个数
void DeleteHead();  //删除头节点
void  DeleteTsil();//删除尾巴
void DeleteNodeRand(int a); //任意位置删除
void FreeList(); //释放链表


int main(void)
{	
	
	InitListHead(); //创建一个空头指针

	//操作
	AddLIstTail(1);     //尾插法
	AddLIstTail(2);		//尾插法
	AddListHead(3);	//头插法
	AddListHead(4); // 头插法
	AddListHead(5);//头插法
	AddListHead(6); // 头插法
	AddListHead(7); // 头插法
	AddListHead(8); // 头插法
	printfList();//打印

	AddListRand(2, 520); //指定位置后面添加
	Gaibian(1,521);  //改变第1个的值为521
	printfList();//打印
	
	DeleteHead(); //删除头节点
	DeleteTsil();  //删除尾节点
	DeleteTsil();  //删除尾节点
	printfList();//打印
	DeleteNodeRand(7);
	printfList();//打印
	FreeList(); //释放
	system("pause");
	return 0;
}
//释放
void FreeList()
{
	STU* liu = g_pHead->next;
	while (liu != NULL)
	{
		STU* pT = liu;   //再找一个新的记住这个节点
		liu = liu->next;	//像下继续走
		free(pT);  //释放
	}
	g_pHead->next = NULL;
	g_pEnd->next = NULL;
		
}
//任意位置删除
void DeleteNodeRand(int a)
{
	//判断链表是不是空的，
	if (g_pHead->next == NULL)  //如果空头下一个节点是空的就是空链表
	{
		printf("链表无头\n");
		return;
	}
	//找a节点
	STU* pTemp = SelectNode(a);
	if (pTemp == NULL)
	{
		printf("查无此节点\n");
		return;}

		//找到以后，判断是头尾还是
	//还要找到他的前一个节点
	 if (pTemp==g_pEnd) //如果删除的是尾节点的话，那就调用尾删除法
		{
		DeleteTsil();
		}
		else   //删除的不是只有一个节点也不是尾节点
		{
		STU* pT = g_pHead;//把pT等于空头的时候就不用再调用头节点删除了，如果是等于g_Head->next的话要有上面的语句
			while (pT != NULL) //pT 不为空
			{
				if (pT->next == pTemp) //如果找到返回 
				{
					break; //跳出出循环
				}
				pT = pT->next; //一个一个给我找 

			}
			//都找到了 该删除了
			pT->next = pTemp->next;//前一个节点指向后一个节点
			free(pTemp);  //把它释放
		}
		
	
}

//删除尾巴
void  DeleteTsil()
{
	//判断链表是不是空的，
	if (g_pHead->next == NULL)  //如果空头下一个节点是空的就是空链表
	{
		printf("链表无头\n");
		return;
		//有尾巴 删除
	}
		if (g_pHead->next == g_pEnd) //如果只有一个节点
		{
			free(g_pEnd);  //直接释放
			g_pHead->next = NULL;  //唯一的一个被释放了就指向空
			g_pEnd = g_pHead;  //让他俩指向一个空节点
		}
		else
		{
			//找到尾节点的上一个
			STU* pTemp = g_pHead->next;
			while (pTemp != NULL) //pTemp 不为空
			{
				if (pTemp->next == g_pEnd) //如果找到返回
				{
					break; //跳出出循环
				}
				pTemp = pTemp->next; //一个一个给我找 

			}
			//找到尾巴上的前一个
			free(g_pEnd);   //把尾巴释放
			g_pEnd = pTemp;   //把找到的变成新的尾巴
			//尾巴的下一个节点要赋值为空
			g_pEnd->next = NULL;
		}

	}

//删除头节点
void DeleteHead()
{
	//判断链表是不是空的，
	if (g_pHead->next == NULL)  //如果空头下一个节点是空的就是空链表
	{
		printf("链表无头\n");
		return;
	}
		//删除
		STU* pTemp = g_pHead->next; //记住要删除的头节点
		g_pHead->next = pTemp->next; //把g_Head指向删除的下一个节点，让下一个变头
		free(pTemp);  //删除头节点
	}

//任意位置添加
void AddListRand(int Index,int a)
{
	//判断链表是不是空的，
	if (g_pHead->next == NULL)  //如果空头下一个节点是空的就是空链表
	{
		printf("链表无节点\n");
		return;
	}
	//找Index节点
	STU* pTemp = SelectNode(Index);
	if (pTemp == NULL)
	{
		printf("查无此节点\n");
		return;
	}
	//找到了,链接到指定位置
	//创建节点
	//STU* Node= CreateNode(a);//调用函数创建,注意，如果是用尾插法调用函数优惠申请一个空间所以把它放在else里
	//链接 想想几种情况
	if (g_pEnd == pTemp)  //是否尾添加
	{
		AddLIstTail(a); //调用尾插法，因为有空头，不用考虑头插法
	}
	else
	{
		STU* Node = CreateNode(a);//调用函数创建，注意，如果是用尾插法调用函数优惠申请一个空间所以把它放在else里
		Node->next = pTemp->next;  //把新建的指向下一个节点的位置
		pTemp->next = Node;  //让上一个节点指向他
	}
}

//查找指定节点位置返回节点地址
STU* SelectNode(int a)
{
	STU* pTemp = g_pHead->next;
	while(pTemp !=NULL) //pTemp 不为空
	{
		if (pTemp->a == a) //如果找到返回
		{
			return pTemp;
		}
		pTemp = pTemp->next; //一个一个给我找 
			
	}
	return NULL; //记得加这句不然 找不到就在最后面一个插入，用的好像还是尾插法
	
}

//改什么什么的值为什么什么
void Gaibian(int Index, int a)
{
	//判断链表是不是空的，
	if (g_pHead->next == NULL)  //如果空头下一个节点是空的就是空链表
	{
		printf("链表无节点\n");
		return;
	}
	//找Index节点
	STU* pTemp = SelectNode(Index);
	if (pTemp == NULL)
	{
		printf("查无此节点\n");
		return;
	}
	//找到了,链接到指定位置
	pTemp->a = a;// 改的值
}

//头添加
void AddListHead(int a)
{
	//定义一个结构体指针接收
	STU* pTemp = CreateNode(a); //定义一个结构体指针接收
	if (NULL == pTemp)
	{
		printf("内存不足\n");
		return NULL; //申请空间失败
	}
	//链接

	pTemp->next = g_pHead->next; //把头节点指向的赋值给新建的
	g_pHead->next = pTemp;  //把节点指向新建的 ，这样头结点就不变了


}

//尾添加
void AddLIstTail(int a)
{
	//定义一个结构体指针接收
	STU* pTemp=CreateNode(a); // 定义一个结构体指针接收
	if (NULL == pTemp)
	{
		return NULL; //申请空间失败
		printf("内存不足\n");
	}
		  //链接

	g_pEnd->next = pTemp;  //把g_End最后一个 节点指向一个新建的节点
	g_pEnd = pTemp;  //把g_End  成为最后一个节点

}

//创建一个空头链表
void InitListHead()
{
	//链表的空 头指针
	g_pHead = (STU*)malloc(sizeof(STU));// 先让头节点申请一个空间
	g_pHead->next = NULL;  //申请内存必备
	g_pEnd = g_pHead; //就一个节点所以 头 尾 都指向他
	
}

//申请一个节点
STU* CreateNode(int a)
{
	//创建一个节点
	STU* pTemp = (STU*)malloc(sizeof(STU));
	if (NULL == pTemp) 
	{
		return NULL; //申请空间失败
		printf("内存不足\n");
	}
	pTemp->a = a;  //节点成员初始化
	pTemp->next = NULL;//申请内存必备
	return pTemp;  //一会调用要排序
}

//打印
void printfList() 
{
	STU* liu = g_pHead->next;
	while (liu != NULL)
	{
		printf("%d  ", liu->a);
		liu = liu->next;
	}
	printf("\n");
}
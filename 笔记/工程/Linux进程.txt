编译的时候 gcc -o liu liu.c -D_LOCK_   就传递了一个  _LOCK_ 的宏定义 -D
程序执行  ./  生成的文件a

	后台运行：./a &    ctrl +c停止
sleep(1)  睡眠1秒钟 
进程状态：	运行态： 进程正在运行，或者准备运行  R
		等待态：进程在等待一个时间的发生或某种系统资源 来唤醒进程 分为可中断和不可中断  S （可中断） D（不可中断）
		停止态：进程被中止，收到信号可继续执行（设置断点听得时候就是发信号让他变成停止态的）T
		死亡态：已终止的进程，但pcd没有被释放（要防止这种哦） Z

查看进程信息：  查看线程信息加上 -L
		ps： 查看系统进程快照  -ef  显示系统中所有进程的简要信息  换成 aux 显示进程运行状态（上面有基础 还有附加buff要查 ）
		后面加管道	|  more 列表查看   加grep 要查看的进程文件名    
		
		top：查看进程动态信息， 没3秒刷新一下
	
		/proc：查看进程详细信息    cd /proc  进入到这个目录下 然后 cd 进程号 ls 查看  cat status 查看详细信息（这一步也可以查看其他的目录信息）
	
进程相关命令：	
		nice：  指定一个优先级去运行进程  数字越小优先级越高（普通用户最小只能是0）
		       如： nice -n 2 ./text  把文件text的优先级改成2	

		renice：  改变一个已有的进程的优先级  和上面一样
		     如：  renice  -n 2 进程号  就把进程号对应的文件优先级换成了2
	
		jobs： 查看后台进程  运行后台进程 后面加 &   然后 jobs直接查看
		fg：   让后台进程在前台运行   fg 1 （运行一个后台进程就会有一个编号）  然后就可以Ctrl +c 结束掉了 
	前台进程 ctrl+z 就变成后台进程 是停止态  用bg 1运行
		bg：  将挂起的进程在后台运行  bg 1运行	

创建进程:		 linux标准头文件<unistd.h>
		fork 函数  没有参数  返回值是 pid_t类型的 （定义好的 可以看成有符号的整形 ） 创建失败返回-1 成功父进程返回子进程的进程号，子进程返回0
	
		getpid() 获取当前进程的进程号
	
	父子进程：	子进程继承了父进程的内容 几乎所有东西都继承了（还是有一些区别的）
			虽然东西一样 但是地址什么都不一样 都是局部变量（他俩都有独立的空间互不影响） 
		父进程先结束：
			子进程就变孤儿了（被init进程收养），子进程变成后台进程
		子进程先结束：
			父进程如果没有及时回收，子进程变成僵尸进程

	执行：	父进程是从main开始执行的
		子进程是从fork()开始执行的 子进程中也可以创建子进程叫 孙进程

结束进程：
		void exit (int a)  头文件<stdlib.h>  a 虽然是整形的，但是只有第8位是有效的   
		void _exit(int a) 头文件<unistd.h>  a 虽然是整形的，但是只有第8位是有效的
	他俩的区别：
		exit 结束进程时会刷新(流)缓冲区，_exit他不会（就是如果缓冲区的内容没有写入实际的文件中，这段内容会被丢弃的）

进程  - exec函数族： 一组函数 一般包括6个函数，进程调用exec函数族执行某个程序
		1）int execl(const char* path,const chararg,..); 执行一个指定的程序，成功是执行指定的程序，失败返回EOF，第一个参数字符串类型（指定一个要执行程序的名称）就是路径（相对或绝对）
			第2个参数开始后面是可变的，参数类型都是字符串类型，都是传递给 参数1程序的参数，参2就是 程序的名称，后面依次是程序的选项和内容
		       最后一个参数必须是空指针NULL  不然就会执行失败
		实例：执行ls命令，显示/ect目录下的所有文件的详细信息  if(execl("/bin/ls","ls"."-a","-l","/ect",NULL)<0){ 小于0那就是失败咯 打印一下 }

		2）int execlp(const char* file,const chararg,..);  和上面都一样 ，他的参1是执行程序的名称，是在PATH环境变量里面查找的（这个还不明白）如果找不到就执行失败
		实例：执行ls命令，显示/ect目录下的所有文件的详细信息  if(execl("ls","ls"."-a","-l","/ect",NULL)<0){ 小于0那就是失败咯 打印一下 }
			这个执行就是这样和上面那个一样
		
		3）int execv(const char* path，char* const argv[ ]) 执行一个指定的程序，成功是执行指定的程序，失败返回EOF。 上面哪两个是 分开一个一个的传进来参数，这个是放进指针数组里面传进来
			数组是可以进行修改的，一个函数 改改数组参数就行了，就像 宏定义变量一样，更加灵活了
			实例：定义一个  char *arg[ ]={"ls"."-a","-l","/ect",NULL};  然后就是 if(execv("/bin/ls",arg)<0) { 失败啥的 }  第一个参数不变，第二个直接传递指针数组名
		
		4）int execvp(const char* file，char* const argv[ ])  和上面一样，跟1）2）类似  
			实例：实例：定义一个  char *arg[ ]={"ls"."-a","-l","/ect",NULL};  然后就是 if(execv("ls",arg)<0) { 失败啥的 }  第一个参数不变，第二个直接传递指针数组名

		5） int system(const char *command)执行成功就返回 这个命令的返回值，失败就返回EOF。  参数就是执行的程序（里面可以包含参数和选项）
			当前进程等待 command执行结束后才继续执行，在main就是主进程等执行结束在向下执行

进程回收：   头文件<wait .h>
	子进程结束后由父进程回收   主进线先结束子进程 孤儿有init进程回收 若没有及时回收就会出现僵尸进程（很恐怖要找林正英）知道父进程结束变成孤儿 然后被init回收
		1) pid_t   wait(int *status)   参数是整形指针，返回值是pid_t类型（等价于整形）status定义一个整形变量传递的时候传地址，也可以穿NULL不接收返回值。成功是返回回收子进程的进程号，失败返回EOF。
	如果当前子进程没有结束，父进程会阻塞，在调用wait函数的时候。 status可以打印出返回的值
		子进程通过 exit、_exit、return 返回某个值（0~255）

判断子进程是否正常结束：	WIFEXITED(status) 判断子线程是否正常返回 返回是真和假
			WEXITSATUS(status) 获取子线程的返回值 从status中提取出来
			WIFSIGNALED(status) 判断子进程是否被信号结束
			WTERMSIG(status) 获取结束子进程的信号类型，上面那个是信号结束的 用它可以查看结束信号的类型	 

		2）pid_t waitpid(pid_t pid, int *status , int option ) 第2个参数和上面wait一样，参1是指定回收的对象，参3是指定回收的方式 。 参1 pid直接传递-1的时候就是任意一个子进程
			成功返回回收子进程的pid（进程号）或0，回收成功直接返回pid进程号，返回0代表要回收的子进程还没结束。失败返回EOF 是出错
			wait 不可以指定回收那个子进程， 这个可以  pid参1就是指定那个进程的。 参3是指定回收的方式 0或WNOHANG。0表示阻塞方式，那个宏是非阻塞（然后返回0是执行还没有结束上面有）

守护进程：	是linux三大进程类型之一
		特点：a）始终在后台运行，b）独立于任何终端（输入不上东西）c）周期性的执行某种任务或等待处理特定事件
	会话和进程组：
		运行一个程序的时候就创建了一个进程组，会话是一个或多个进程组的集合。通常用户打开一个终端时，系统会创建一个会话。所有通过该终端的进程都属于这个会话，终端关闭时所有进程会被结束			

	创建：	1）创建子进程，父进程退出    if(fork()>0){exit(0)}  大于0是创建成功 然后父进程退出。
			变成孤儿进程 被init进程收养，子进程在后台运行
		2）子进程创建新的会话：setsid()函数  if(setsid()<0){ exit(-1); }创建一个新的会话，子进程成为新的会话组长，与原先的终端脱离
		3）修改进程的当前工作目录： chdir()  参数就是目录路径  chdir("/tmp")  tmp目录可读可写， 守护进程一直在后台运行，其工作目录不能被卸载。重新设定当前工作目录cwd
		4）修改当前文件权限的掩码： umask(0)参数是文件权限 一般设置成0   if(umask()<0){  exit(-1);}  把文件掩码设置成0，只影响当前进程
		5）关闭从父进程继承的所有文件：getdtablesize() 当前程序打开文件的最大个数。for(int i=0;i<getdtablesize();i++){ close(i)} 关闭打开的文件描述符，
			关闭所有从父进程继承的打开文件，脱离终端 stdio、stdout、stderr标准输入、输出、错误 无法使用


Linux线程：		 头文件<pthread.h>   编译的时候 记得在加上后面那个链接选项   如： gcc -o 文件名 类型  -lpthread
		pthread线程库中提供了 创建线程、回收线程、结束线程  同步和互斥机制：信号量和互斥锁	

	创建线程：	int  pthread_create(pthread_t *thread , const pthread_attr_t * attr , void *(*routine)(void *), void *arg)   成功返回0，失败返回错误码
				参1线程对象（要自己限定义 pthread_t 变量名，传的时候&变量名），
				参2结构体指针（指定创建线程的属性，一般就是NULL代表默认属性）参3是线程函数。参4是线程函数的参数无参传NULL

	回收线程：	int pthread_join(pthread_t thread, void ** retval)  成功返回0，失败返回错误码  
				参1 是要回收的线程对象， 参2 是2级指针是用来接收线程返回值的  1级指针传地址就是2级（这个也是先定义好的 void *liu 传递&liu）
			线程没结束执行这个会阻塞啊
	
	结束线程：	void pthread_exit(void *retval)  结束当前线程	 retval可被其他线程通过 pthread_join（线程回收）获取，线程私有成员被释放（不要是在线程创建的对象，最好是全局吧?）
				pthread_exit("hello world");   线程结束返回hello world	
				也可以用return 和他是等价的	

信号量： 
		初始化  对信号亮进行初始化
		P操作（申请资源）线程要去访问资源的时候申请 如：  if(信号量的值大于0){ 申请资源的任务继续运行；信号量的值-1} else { 申请资源的任务阻塞} 相似于C++上锁
		V操作（释放资源） 释放了资源（产生了资源）  如：信号量的值+1 if(有任务在等待资源){ 唤醒等待的任务让其继续运行}  他是不会别阻塞的 相似于C++解锁

	Posix 信号量：
		1）无名信号量（基于内存的信号量）
		2）有名信号量 ：既可以用于线程也可以用于进程

	pthread库常用的信号量操作函数：
			头文件<semaphore.h>
		1）int sem_init( sem_t * sem , int pshared , unsigned int value) 初始化  成功返回0 失败返回EOF（-1）  先初始化好信号量在创建线程 
			参1指针指向要初始化的对象（调用要定义一个 sem_t 变量传地址进去），参2是信号量的使用范围 0是代表线程间 1代表进程间（非0） 参3代表信号量的初值 0代表无资源 大于0有可操作
				
		2）int sem_wait( sem_t *sem) P操作     成功返回0 失败返回EOF（-1） 参数上面那个参1一样
		3）int sem_post(sem_t *sem)  V操作    成功返回0 失败返回EOF（-1）

互斥锁：		头文件<thread.h>
		临界资源 共享的 一次只允许一个任务访问
		mutex 互斥锁：          也要先初始化在创建线程
			1）初始化锁：  int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t* attr ) 成功返回0 失败返回 错误码
				参1mutex指向要初始化的互斥锁对象 就是pthread_mutex_t 定义的变量传地址进去。参2互斥锁属性，NULL表示缺少实行

			2）申请锁：  int pthread_mutex_lock(pthread_mutex_t *mutex) 成功返回0失败返回错误码  如果无法获得锁 任务阻塞
				参数  mutex指向要初始化的互斥锁对象

			3）释放锁： int pthread_mutex_unlock( pthread_mutex_t* mutex)成功返回0失败返回错误码  上锁后 执行完临界区 及时解锁
				参数 mutex指向要初始化的互斥锁对象

线程结束

进程的间通讯方式：
		 是从UNIX继承来的  分 有名管道(fifo)、无名管道(pipe)、信号(signal)这是早期的
		       System V IPC ：共享内存(share memory)、消息队列(message queue)、信号灯集(semaphore ste)
			还有  套接字(socket) 不学 有空去学一下  上面是一台电脑的通讯  这个是通过网络不同电脑来通讯的   
			
大小64k	1）无名管道：	特点 a）只能用于具有亲缘关系的进程之间通讯，父子进程、兄弟进程、阻塞的这种
					b）单工的通讯模式，具有固定的读端和写端（不允许同时读写无名管道）
					c）创建无名时 会返回两个文件描述符  读端和写端
			 创建：  <unistd.h>
					int pipe( int pfd[2]) 返回值是整形  成功返回0 失败返回EOF(-1)  要实现 读和写就要两个进程 一个干不了
						参数是 整形数组 pfd包含两个元素的整形数组，用来保存文件描述符 [0] 用于读管道  [1]用于写
					管道内容读走以后就不存在了，普通的读走还在		

				A）写端存在： 父进程创建了子进程（继承了父进程）都是有两个读和写  至少有一个是写的 就叫做写端存在（因为一个线程只可以进行一个操作）
					a）有数据   read返回实际读取字节数（就是要读多少数据）
					b）无数据   进程读阻塞（直到其他进程网管道写入数据）
				B）写端不存在：进程读数据
					a）有数据   read返回实际读取字节数（就是要读多少数据） 和上面一样
					b）无数据   不会阻塞  read直接返回0
				
				C）读端存在：至少有一个文件描述符去读取 和上面写端一样
					a）有空间  write 返回实际写入空间的字节数   
					b）无空间  1 空间不足：写写着着没了  进程阻塞 就会等有空间了在继续写入，直到写完不阻塞   
				D）读端不存在： 进程写一个没有读端的管道，进程就会异常结束 叫做管道断裂

	2）有名管道：	特点 ： 无名管道只能用于有血缘的管道之间
				a) 对应的是具体的管道文件，可用于任意进程之间的通信
				b）打开管道时可以指定读写方式，读打开就是读端 写就是写端，读写就是双端咯
				c）通过文件io操作，内容存放在内容中，就是创建的管道文件大小永远是0 因为内容都在内存中
				d）打开一个管道文件 只有一个读 或写  会阻塞 （没有任何意义）读写都存在才被打开		
			
			创建：	头文件<unistd.h> <fcntl.h>
				int mkfifo(const char* path , mode_t mode)  成功返回0，失败返回EOF				
					参1 是创建的有名管道的路径还有名字（相对绝对都行），参2是创建有名管道的权限 是读 写 还是都行 如0666（八进制数）

	3）信号机制： 	kill  -l 显示所有支持的信号类型（前31中称不可靠信号）
			信号是在软件层次上对中断机制的一种模拟（中断指CPU的执行），是一种异步通信方式（一个进程在任何的情况下都可以接受一个信号不需要任何的处理）
				Linux内核通过信号通知用户进程，不同的信号类型代表不同的事件。
		进程对信号有不同的响应方式 ：
			 a）缺省方式（常用的信号缺省处理） 
			 b）忽略信号（收到了信号相当于没有收到，忽略了直接 ） 
			 c）捕捉信号（某一个或某些信号设定一个信号处理函数，进程收到后会执行定义好的信号处理函数）
	常用信号：
		SIGHUP：在用户终端关闭时产生，这个信号会发送给所有依附终端的进程    	默认操作是：终止  。发信号让他们都终止	
		SIGINT ： 在用户输入ctrl+c的时候产生 发送信号个诶当前终端的所有前台进程  	默认操作：终止  。 
		SIGQUIT： 在用户输入 ctrk+\ 产生， 和SIGNT类似 发给前台   		默认操作： 终止
		SIGILL ：有一个非法指令产生，就发这个信号 让指令终止  			默认操作：终止
		SIGSEV： 当非法访问内存时产生 如 野指针和缓冲区溢出，然后打信号终止  	默认操作：终止
		SIGPIPE：当进程没有读端写入是，管道断裂 发信号让停止			默认操作：终止
		
	->	SIGKILL：让进程结束，无论出于什么状态都结束，并且不能被捕捉和忽略		默认操作：终止
	->	SIGSTOP：让进程出于停止态，并且不能被忽略				默认操作：暂停进程
		SIGTSTP：作用和上面类似，用户输入ctrl+z 发送信号			默认操作：暂停进程
		SIGCONT：让进程进入运行状态					默认操作：继续运行
		SIGALRM：定时器信号，时间一到就终止	（通常用在捕捉）			默认操作：终止
		SIGUSR 1/2：该信号保留给用户程序使用					默认操作：终止

	信号相关命令：  
·		kill  -l 显示所有支持的信号类型（前31中称不可靠信号）
		kill  [-signal] pid  	 默认发送  SIGTERM  （上面查信号的第15） -sig可指定信号	pid指把信号发送给谁 发送的对象，也可以给进程组发信号，通常是给进程
		kill -9  1314  	就是想1314进程号发送 上面查信号的第9个 这个信号
		kill  -9  -1314	就是向 1314的进程组 发送信号9
		kill  -9  -1 	就是除了系统进程和当前运行的进程，给所有的进程发信号9 很危险的哦

		killall  [-u Linux  |   liu]   Linux是指定的用户名，liu是指定的进程名
		killall a.out   没有参数就是默认向他发送15的信号	
		killall -u  linux	向所有linux这个用户创建的进程发送15这个信号

	发送信号：头文件  <unistd.h>  <signal.h>
		函数：	a) int kill( pid_t pid , int sig)   发送信号  成功返回0 失败返回EOF(-1)
				参1pid接收进程的进程号；0代表同组进程（当前进程的同组进程），-1代表所有进程（除了系统进程和我当前进程之外的所有进程）
					也可以发送给进程组号，获取进程号也可以给某个进程号发信号
				参2 sig信号类型（一般都是用宏 就是上面写的那些） 指定要发送信号的类型
			
			b） int raise(int sig) 向当前进程发信号（自己给自己发信号）
				参数是要发送的信号类型 和上面的参2一样
		
	创建定时器：  头文件同上
			c） int alarm( unsigned int seconds) 创建一个定时器，成功返回定时器剩余时间，失败返回EOF(-1)  参数是 定时器的时间 如果变量传递的是0 就是取消定时器咯
				linux中只能有一个定时器，设置新的 旧的就会失效，新的会返回旧的定时器剩余的时间

			d）int  pause(void) 进入一个等待态（睡眠） 知道收到信号 被唤醒 。 被唤醒后返回-1

	设置信号响应方式： signal 上面 有提到 捕捉 忽略
			void (* signal(int signo,void(*handler)(int )))(int )     成功返回原先的信号处理函数，失败返回SIG_ERR（特定的一个值）  看着很难下面实例，就很离谱
				参数 signo是任何一种合法的信号类型（宏定义）(除了上面->哪两个不能被忽略和捕捉的，哪两个级别高)
				参数 handler 是一个函数指针，存放的是一个函数的入口地址，用的时候先定义好一个信号处理函数 把函数名代表函数地址的实参传递，它有个整形的参数	
					指定信号处理函数：SIG_DFL 代表缺省方式， SIG_IGN 代表忽略信号  因为 前面参数不可以忽略和 捕捉 这个来弥补一下

 			实例： 主函数：signal(SIGINT ,handler )；   signal(SIGQUIT , handker);  while(1) pause(); return 0;
				handler函数实现	 void handler( int signo){ if(sigo==SIGNT){ printf("Hello world111 \n"); }  if(signo== SIGQUIT){ printf("Hello world222"); }  }  
				 
		
System V IPC：	IPC对象 包含：共享内存、消息队列、信号灯集
			特点：每个IPC对象有唯一的ID  IPC对象创建以后就一直存在，直到被删除（不想管道终端关闭他就关闭）专门的函数、命令显示的删除。要主动的删除
				每个IPC对象有一个相关联的KEY（IPC对象的属性）通过他可以让不同的进程 对象找到IPC并打开，KEY是0时 表示是一个私有的对象（把KEY设置0 别的进程就获取不到了）
					非0就是和ID 一 一对应的  指定KEY 为 IPC_PRIVATE（就是0） 非0 是key_t 变量
	
	命令：ipcs 显示出系统当前的IPC对象   -l  会列出关于IPC 对象 的共享内存 消息队列 信号灯 大小什么的属性  可以用什么命令来修改 大小值（去查吧 ）
	         ipcm 删除 	共享内存-m id   -M key 、消息队列 -Q key  -q  id、信号灯集  -S key  -s id
		
		生成一个KEY值：   头文件<sys/types.h>  <sys/ipc.h>
			 key_t  ftok(const char * path , int proj_id) 生成一个key值   成功返回合法的key值 失败返回EOF(-1)  下面有实例
				参1 路径 当前文件可以访问的，并且存在 . 代表当前目录 参2 用于生成key的数字，不能为0 一般传递字符常量 int ‘a’  Asics码 转换

	共享内存：
		特点： 效率最高的一种进程间的通讯方式，可以直接读写内存，不需要任何数据的拷贝
			存在内核空间创建，可映射到用户空间访问，使用灵活  
			因为可以多个进程的访问  所以要配合上 同步和互斥机制使用

		使用步骤： 1）创建、打开共享内存 
			2）映射到进程的访问空间			
			3）读写共享内存
			4）撤销共享内存映射    这是在读写结束后
			5）删除共享内存对象   不删除一直存在，或者系统结束


		1）创建函数：  头文件<sys/ipc.h>   <sys/shm.h>
			int shmget(key_t key , int size , int  shmflg) 创建或者是打开一个共享内存对象	 成功返回共享内存的id 失败返回EOF(-1)
				参1 是和共享内存关联的key值  可以直接传递 IPC_PRIVATE （这个是私有的哦） 或者是用 上面 ftok()函数生成
				参2 是指定共享内存的大小 字节为单位
				参3 shmflg 指 共享内存的标志位 IPC_CREAT （传递这个是是否新建，参1是私有的就不需要加它了私有的就是新建的只传递权限） | 0666共享内存的权限  0666是所有用户可读可写
			实例： key_t key； int shmid； if((key==ftok(".",'m'))==-1){ 错误处理} 这是生成一个key值
				if((shmid==shmget(key,1024,IPC_CREAT | 0666))<0) {错误处理} 这就是创建一个共享内存  大小是1024个字节，权限是0666可读可写

		2）共享内存映射：  头文件<sys/ipc.h>  <sys/shm.h>
			void *shmat(int shmid, const void *shmaddr , int shmflg) 根据共享内存的id 吧映射到进程的 地址空间。 返回值 是一个指针，成功返回映射后的地址，失败返回特殊的值(void *) -1 貌似会强转
				参1 shmid 要映射的共享内存id
				参2 shmaddr 映射后的地址 ，NULL表示有系统自动映射（一般就传递NULL）
				参3 shmflg 标志位 0表示可读可写，SHM_RDONLY表示只读
			实例： char *addr；int shmid； if((addr=(char *)shmat(shmid,NULL,0))==(char *)-1) {  失败处理}这个是字符串的读写所以是char*  别的类型是别的指针
				fgets( addr,N,stdin) 往共享内存写数据 这是addr现在就是共享内存的首地址 ，N是共享内存的大小（防止越界）	

		3共享内存撤销映射：头文件<sys/ipc.h>  <sys/shm.h>
			int shmdt(void *shmaddr) 取消共享内存的映射  成功返回0 失败返回EOF(-1)
				参1 就是映射后的首地址  。 不使用共享内存时 应撤销映射，没有撤销进程结束 也会自动撤销(要养成习惯 自己来撤销）

		4）共享内存控制：头文件<sys/ipc.h>  <sys/shm.h>
			int shmctl(int shmid , int cmd , struct shmid_ds* buf) 对共享内存进行各种控制和设置  成功返回0失败返回EOF(-1)
				参数1 shmid 要操作的共享内存id
				参2 cmd 要执行什么样的操作 传递 IPC_STAT（获取当前共享内存的属性，存放在参数3里面）  IPC_SET（设置一个共享内存的属性） IPC_RMID（删除共享内存的id 还有很多定义好的宏）只列出3个 
				参3  定义一个结构体变量 传他的地址进去， 上面第3个宏用不到这么参数 就直接传NULL  保存设置共享内存的地址 根据上面的宏定义来实现进行操作
		
		注意事项：	1）每块共享内存有大小限制
				2）共享内存删除的时间点（应该是由最后一个进程来删除） 用上面的代码 参数是 shmtcl(shmid , IPC_RMID ,NUULL) 就是删除操作（添加删除操作），
					但是要等到对某一个共享内存的映射标记为要删除的时候，共享内存在会真正被删除
					每一个贡献该内存中都有一个 nattach 当有进程调用他的时候就会+1   他变成0时才是真正的删除，他不为0表示还有内存映射着呢 是不会被删除的  当相关的进程都结束了（会自动取消映射）


	消息队列：是System V  IPC 的一种， 有唯一的id， 消息队列就是一个消息的队列。用户可以在消息队列中 添加消息、读写消息等
			支持不同的消息类型，可以按照类型来发送/接收消息

			1）创建/打开  消息队列： 头文件 <sys/ipc.h> <sys/msg.h>
				int  msgget(key_t key ,int msgflg) 创建/打开一个消息队列。成功返回消息队列id，失败返回EOF  可以参考上面共享内存创建
					参1 key和消息队列关联的key  可以直接传递 IPC_PRIVATE（这个是私有的哦，好像是0） 或者ftok 生成一个key值
					参2 msgflg 标志位 IPC_CREAT | 0666 上面 共享内存创建的时候和这个一样 					

			2）向消息队列发送消息：头文件 <sys/ipc.h> <sys/msg.h> 要先定义一个结构体用来 传递参2 直接传结构体地址 ，首个成员必须是long类型（不可以是0和负数）
				int  msgsnd( int msgid , const void* msgp , size_t size , int msgflg )  成功返回0，失败返回EOF(-1)
					参1 就是 消息队列id  
					参 2是一个地址，存放的就是要发送的消息（消息缓冲区的地址）先定义一个结构体变量，传递结构体地址（因为格式内容都是结构体定义的）
					参3 就是消息要发送的长度(消息正文长度）  后面有消息队列格式
					参4 是一个标志位  0 或 IPC_NOWAIT。 0是 消息队列满了 发不进去了就阻塞，IPC_NOWAIT是不管消息有没有成功不需要等待就可以完全返回
				
			3）从消息队列接收消息：头文件 <sys/ipc.h> <sys/msg.h>   接收的时候也要先定义一个和发送一样的结构体来接收内容
				int msgrcv(int msgid,void *msgp ,size_t size , long msgtype ,int msgflg) 成功返回收到的消息长度，失败返回EOF（-1）
					参1 消息队列id
					参2 是一个地址，存放缓冲区的地址，先定义一个结构体变量，传递结构体地址（因为格式内容都是结构体定义的）
					参3 指定要接收的消息队列的长度是（一般约定好，不然会丢失）
					参4 指定要接收的类型（发送不用因为在结构体的首成员就是发送定义结构体 的第一个成员值long a=100；这就是100）发送消息是对方的类型，接收是自己的类型
						指定成0 就不是按照消息的类型接收了而是接收消息队列中最早的一个消息（具体是指定类型还是具体时间可以根据自己灵活运用）
					参5 是标志位 0 有消息的时候接收消息并返回接收的长度，没有消息进程会阻塞（要么有消息 要么消息队列被删除）
						IPC_NOWAIT是 有消息就接收返回，没有消息就不阻塞 返回一个错误告诉你当前进程没有消息

			4）控制消息队列：头文件 <sys/ipc.h> <sys/msg.h> 
				int msgtcl(int msgid , int cmd ,struct msqid_ds *buf) 成功返回0 失败返回EOF（-1）
					参1 消息队列的 id
					参2 cam要执行的操作  IPC_STAT    IPC_SET   IPC_RMID 还是共享内存控制的那三个（在上面参考）
					参3 buf 用来存放队列属性的地址 和共享内存不一样的是 都要结束映射才可以删除，这是直接就可以删除

		消息队列格式：根据用户需求定义结构体类型（格式） 结构体中第一个成员必须为long类型代表当前的消息类型（正整数不可以为0和负数）除了第一个外 别的成员都属于消息正文

	System V IPC 信号灯机制：
			信号灯也叫信号量，用于进程/线程同步或互斥的机制
			类型：Posix 无名信号灯  线程中的同步（也可以用来互斥）
			      Posix 有名信号灯  用于进程之间的 同步 和互斥
			  System V IPC 信号灯  在不同的进程和线程之间来同步和互斥
			
			含义： 计数信号灯 它是有值的 这个值就是他的数量 无名有名都是计数信号灯
			System V IPC  信号灯可以操作多个信号灯（V操作和P操作只可以操作单个） 记得申请多个资源时 小心死锁	

		使用步骤：
			1)打开/创建信号灯   头文件<sys/ipc/h>  <sys/sem.h>
				int semget(key_t key , int nsems, int semflg)  成功是返回id  失败是返回EOF(-1)
					参1 key值 课信号灯关联的key值，可以传递IPC_PRIVATE或ftok() 
					参2 nsems 集合中包含信号灯的个数（每个信号灯代表一类资源）
					参3 标志位 IPC_CREAT | 0666(和key关联的信号灯不存在就创建 存在就打开返回id )IPC_EXCL可以配合前面的使用 用他 |  就是新创建的执行成功，已被其他进程创建了 就返回错误 

			2）信号灯初始化（既可以初始化又可以删除）：头文件<sys/ipc/h>  <sys/sem.h>
				 int semctl(int  semid,int semnum ,int cmd, ...) 成功返回0 失败返回EOF(-1)
					参1  semid 要操作的信号灯集的id	
					参2 semnum 要操作集合中的信号灯编号 （信号灯编号是从0开始创建的） 可以包含多个信号灯 0 1 2
					参3 cmd 信号灯要执行的操作 SETVAL（来设置信号灯的值）  IPC_RMID（删除整个信号灯集合） 有可能是3个参数也可能是4个 取决于 它 。
					参4  当 参3 传递 SETCAL设置的时候 就会有第4个  union senum  变量(共用体类型哦） 要自己定义的，具体类型还是要 命令 man semtcl 去查（百度也行）
				实例：假设信号灯集合中包含两个信号灯;第一个初始化为2，第二个初始化为0
					union senum myun； myun.val=2；  if(semtcl(semid,0 ,SETVAL,myun)<0 ){ 错误处理 } 参数0 是要操作的信号灯编号（因为是从0开始创建的，那么下一个当然就是1了） 
						myun存放的是初始化的值（2），这个函数就是把第1个信号灯设置成2
					 第2个信号灯 初始化为0  myun.val=0； if(semtcl(semid,1 ,SETVAL,myun)<0 ){ 错误处理 } 把第2个信号灯 设置成了0

			3）P/V操作 ：头文件<sys/ipc/h>  <sys/sem.h>
				 int semop(int semid, struct sembuf* sops , unsigned nsops) 成功返回0 失败返回EOF(-1)
					参1 要操作的信号灯集id
					参2 sops 描述对信号灯操作的结构体 数组[],这个结构体是头文件中已经定义好的结构体 ，结构体里描述的事每一个信号灯的操作（操作多个的时候记得传结构第地址）
					参3 nsops 根据结构体传递的参数 按照结构体的操作对应的信号灯，无符号整形的 类型 要操作的信号灯的个数
					  参2 的结构体定义： struct sembuf { short semnum； short sem_op；short sem_flg； }； 第1是要指定的信号灯的编号(如果有3个信号灯编号 就是从0~2) 
						 第2 -1 是V操作 1是V操作（上面有这两个操作是干嘛的） 第3是操作方式  一般就是两种  0和 IPC_NOWAIT，
							P操作0 时 阻塞知道完成返回或者出错， IPC_NOWAIT是直接返回（成功与否） 
					实例：先定义一个参数2需要的 结构体数组（操作2个信号举例）  struct sem_buf buf[3]; buf[0].semnum=0//这是信号灯编号首个 buf[0].sem_op=-1; buf[0].sem_flg =0;  
						buf[1].semnum=2这是信号灯编号第2个因为有3个0~2， buf[1].sem_op=-1; buf[1].sem_flg =0;
						然后就调用 P/V 操作函数 semop( semid ID ，&buf   , 2)  第一个是id ，第2 是结构体数组，第3 是2从结构体数组中取出的个数
			

	我的天哪！ 完结了 全程懵逼好嘛！！ 不懂不懂不懂！

 		


  	！！！STL 标准模板库！！！

6大类：容器、迭代器、算法、3重点，适配器、分配器、仿函数、介绍


vector：
	遍历	for_each(起始，结束 ，函数名)   除了用迭代器还可以用这个函数 直接遍历
			void f(int a){ cout<<a<<endl;}
string:
	可以 +=  直接在字符串后面加上

迭代器：
	使用只读的迭代器 加了const以后 创建迭代器要加上 const 
		例如： vector<int >const_iterator it; 

stack：	栈容器 <stack>
	构造函数：默认: stack<T> stk;    拷贝构造 stack(const stack &sck);
	赋值操作：重载了 = 号
	数据操作 ： push() 进栈、  pop()  出栈、 top()返回栈顶元素 
	大小操作： empty()  判断是否为空  、size() 返回栈的大小				

queue:	队列容器 <queue>
	构造函数：默认: queue<T> que;    拷贝构造  queue(const  queue &quek);
	赋值操作：重载了 = 号 
	数据操作 ： push() 进队、  pop()  出队、 back()返回最后一个元素 、front()返回第一个元素
	大小操作： empty()  判断是否为空  、size() 返回队列的大小		

pair 对组： 创建 pair<string,int> p("刘士朋",21); 创建  p.first是第一个元素，p.second是第二个元素
		pair<string,int> p=make_pair("马娟"，18);

算法：
	不支持随机访问的迭代器时： sort 用成员函数调用   对象.sort()（没有迭代器参数） 如果类型复杂 写一个仿函数：
		当参数 bool f(int a,int b){ return a<b;}这样就可以以什么判断来排序了 这个底层是 没有一个参数就把他的结果传进函数中当参数 是类的话 . 成员来运算
	把一个对象搬到另一个对象：
		transform(it.begin(),it.end(),it2.begin(),仿函数) 用这个函数it2 要有空间  仿函数可以用下面逻辑仿函数，不想用直接return（传进去直接还返回他不运算）
	遍历：	for_each(it.begin(),it.end(),函数或仿函数) 参数是遍历的值类型 他每个数据都穿进去 然后自己实现里面打印
	查找：
		查找元素		1）find(begin,end,值) 有就返回位置，没有返回end迭代器 自定义类型记得重载==号 让他知道怎么判断相等的 用返回值bool类型 
		按条件查找元素	2）find_if(begin,end，仿函数|谓词) 用类写个仿函数 来确定参数找什么样的元素   返回也是跟上面一样
		查找相邻重复元素	3)  adjacent_find(begin,end) 返回相邻切重复的第一个位置 必须是重复且相邻的  不然不算 
		二分查找法	4)binary_search(begin,end,值) 查找指定元素是否存在  找到返回真  否假 只可以在有序的序列里用
		统计元素个数	1)count(begin,end, 值) 找到和值一样的数有多少，自定义数据类型 要写==重载
		按条件统计元素个数	2)count_if(begin,end,谓词) 自己写谓词 条件，返回bool类型
		
	排序：	对容器内进行排序			sort(begin,end，)3可有可无 如果倒叙可以仿函数实现
		洗牌 指定范围内的元素随机调整次序	random_shuffle(begin,end)把 序列打乱 要加随机数种子 不然一直就是这个结果
		容器元素合并，并存储待另一个容器中	merge(begin1,end1,begin2,end2,it3) 两个容器必须有序 合成的也是有序的   这个容器要有容量！！
		翻转指定该范围元素			reverse(begin,end)  就反转呗
	
	拷贝替换：	拷贝				copy(begin,end,begin2) 可以任意迭代器区间位置 拷贝的要记得申请空间
			指定范围内的旧元素修改新元素	replace(begin,end,20,2200) 把20 替换成2200 
			指定范围内满足条件的旧元素修改新元素	replace_if(begin,end,仿函数，200) 仿函数里面设置条件 满足的都替换成200
			互换两个容器的元素			swap(容器1，容器2)类型要一样 交换

	算术生成算法：生成属于小型算法 <numeric>
			计算容器元素累计总和：	accumulate(begin,end,0)计算区间内元素总和,从0开始加
			像容器中添加元素：		fill(begin,end,100)把这个区间位置填写成100
	集合算法：
			求两个容器的交集	set_intersection(begin1,end1,begin2,end2,it3.begin)记得给it3申请空间(min(1.size(),2.size()))。返回得失迭代器的end 打印到返回的这个迭代器里面就是他俩的交集
			求两个容器的并集	set_union(begin1,end1,begin2,end2,it3.begin)记得申请空间（两个容器相加） 必须是有序的序列  返回值是并集中最后一个元素的位置
			求两个容器的差集	set_difference(begin1,end1,begin2,end2,it3.begin)记得给it3申请空间(max(1.size(),2.size()))       求1和2的差集，2在前就是2和1。返回得失迭代器的end 打印到返回的这个迭代器里面就是他俩各自的差集
		


仿函数：  函数对象 重载函数调用的操作符的类，叫做函数对象 ，函数对象使用重载的()时，行为类似函数调用 也叫仿函数
	仿函数是一个类 不是函数
	在类中写填参数加上()
	使用：1、 可以向普通函数那样有参数和返回值 就是他在类中 
	          2、 可以有自己的状态 超过了普通函数 因为他是类，可以创建其他成员来操作
	
	谓词：返回bool类型的仿函数称谓词 形参列表由一个参数是一元谓词，两个参数就是二元谓词 返回类型必须是bool
		函数参数是 _Pr _Pred 就是要的谓词
算术仿函数： 已经重载好了 直接拿来用 <functional>
	一元运算： negate<T> 取反
	二元运算：1、加法 plus<T> 2、减法 minus<T> 3、乘法 multolies<T> 4、除法 divides<T> 5、 取模 modilus<T> 6、取反 nefate<T>
  	关系运算符：1、等于 equal_to<T> 2、不等于not_equal_to<T> 3、大于greater<T> 4、大于等于greater_equal<T>5、小于 less<T>6、小于等于  less_equal<T>
		这个可以直接在 sort这种代替仿函数的位置 还不如自己来写呢 大于greater<要跟排序的类型一样> 
	逻辑仿函数：与、logical_and 或、logical_or 非、 logical_not  返回bool类型
		
容器：
顺序容器：头文件<string>
	string：是专门字符串操作的一个类，非常强大，字符串 CString，QString。头文件<string> 要和标准命令空间一起使用（using namespace std；）
	   和char*的区别：char*可以当做字符串的首地址来操作 <string.h>有很多操作函数。string则是一个类，将前面的函数操作封装到一起，是操作更灵活，方式更多，管理更合理
	  string这个类使用的时候不用考虑内存的分配和释放，越界崩溃，前辈在封装的时候几乎把所有情况都考虑到，并处理了
	使用：因为是封装好的类，使用的时候直接声明对象就行了 如：string 对象；没传参数默认就是无参数的构造函数，（不对他用数据成员的操作就让他成为常函数 const）
	可以直接用cout输出，因为重载运算符里面写了 string，
	注意：不可以用下标运算增加赋值，可以查找，可以修改已存在的	
	构造函数 	1、string 对象(5,'a;);打印5个a，
		2、 string 对象("abcdefg")打印adcedfg，
		3、 string 对象("abcde"，3)打印3个，前几个
		4、string 对象1(对象2，1,3)；参数是对象2，1后面的3个 给对象1
		5、string 对象1(对象2)   没错就是拷贝构造，懂，记得用深拷贝？
	string 重载的运算符：<< 输出 可以直接输出对象打印字符 cout<< 对象；
			   >> 输入 出入之后打印对象会把原来的覆盖掉 cin>> 对象

string函数：	1）对象.empty( ) 空串返回1，不是返回0，
	属性：	2）容量：对象.capacity( ) 得到容量 一个空的字符对象 的容量是15（可以装下15个字符）当这15个存满在申请16个，存满在申请16个，少于等于15申请15个，以后多余加增加16个（vc6.0是31,32）
	       	3）修改容量大小： 对象 .reserve( )  不能变小只能变大， 在(10)小于15忽略，(16)就直接变成31了再多同上（直接+了）
		4）字符长度：对象.length( )  得到字符的长度。4））字符个数：size( ) 结果是一样的
		5）截断字符串：对象.resize(3); 把字符串截断成3个，就相当于只有3个 别的都删了
		6）大小长度：对象.size() 用来for() 循环获取单个字符  可以 对象[i]获取单个字符 
		
	转换为：	char*   对象.data(); ||  对象.c_str();

	输出：	全部输出：  这个因为重载了string 对象 所以可以直接输出，他是字符串的备份不是本身：cout<<对象名；
		函数输出：对象.c_str( )；	输出原理都是一样的 他的作用只有一个return 指针 ，返回字符首地址
		输出单个字符：可以用 [ ] 下标运算符来访问 数字是几就输出下标多少的字符（越界系统崩溃，），指针对象不知道怎么用
			函数：对象.at(2)  就打印下标为2的字符 （越界系统崩溃，可以去找奔溃的异常操作 try catch）下标不可以修复

	修改：	修改指定元素：[ ] 下标运算和 at( ) 函数，还用说吗？ 都可以得到第几个的值了，直接 = 赋值就行了
		
	插入：	1）对象.insert(3,对象)； 在下标3的位置插入一个字符串对象	
		2）对象.insert(3,"Hello world"); 在下标3的位置插入一个hello world
		3）对象.insert(3,对象，1,5); 在下标3的位置插入 对象从第1个下标开始的5个元素
		4）对象.insert(3,对象，5) 在下标3的位置插入，对象下标5后面的都插入
		5）对象.insert(3,5,'a')在下标3的位置插入 5个a

	尾巴插入：1）对象.apend(对象) 在后面插入一个对象
		2）对象.append("hello")在后面加上
		3）对象.append(对象，2,5) 插入一个对象 从下标2到下标5
		4）对象.append(对象，5)从对象下标5开始全部插入到后面
		5）对象.append(5,'a') 在后面插入5个a

	重新赋值：1）对象.assign(对象)重新赋值，和对象一样
		2）对象.assgin("hello")以字符串赋值
		3）对象.assgin("hello",3)赋值前3个值
		4）对象.assgin("helloliushipeng",3，5)从下标3开始一直赋值5个
		5）对象.assgin(5,'a') 赋值5个a
	
	删除：	1）对象.erase(1，3) 删除从下标1开始的三个字符
		2）对象.erase(position) 删除postion处的一个字符（position是一个string类型的迭代器）还不会用！！  下面有
		3）对象.erase(first,last)删除从first到last之间的字符（first和last都是迭代器）  还不会用！！    下面有
	
	替换：	1）对象.replace(1,3,"11111");从下标1 开始的3个字符替换成11111
	
	比较：	可以比较两个对象也可以比较两个字符串。6个比较符 ==，>，<，>=，<=，!=。。真就返回1，假就是0咯，compare是大于返回1，小于返回-1，等于返回0
		如：cout<<(对象1>对象2)；  对象比较字符串("hello">对象)
		函数是：compare 使用可以用上面那种不用函数直接比较的，上面是真返回1，假返回0，下面就不一样了
	用函数：	1）对象.compare(对象2) 和对象比较，对象大返回1，对象2大返回-1，等于返回0
		2）对象.compare("hello")和字符串比较，对象大返回1，字符串大返回-1，等于返回0
		3）对象.compare(3,1,对象2)  用对象的第3个小标字符和对象的第1个比较，对象大返回1，对象2大返回-1，等于也是-1（应该是返回0的，vs2017测试一直是-1）
		4）对象.compare(3,1,对象2,1,3) 对象从下标3开始的1个和对象2下标1开始的3个比较

	复制：	1）对象.copy(字符串，2,3)将对象从下标为3的位置 复制2个字符 给字符串，记得给字符数组初始化，注意会越界

	查找子串：1）对象.find(对象2,0)从0下标查找和对象一样的子串，和KMP算法类似，找到返回下标从哪开始的，找不到返回4294967295这个是无符号整形，强转成int型（也就是-1）(int)对象.find(对象2,0)
		2）对象.find("hello"，2)从对象下标2开始查找一样的，找到返回所在下标，找不到和上面一样
		字符串有一个字符就相当于找字符了
		还有 rfind()  他俩的区别就是 这个是从右往左查找，find是从左往右
		
	返回子串截取：对象.substr(2,4)  他的返回值是当前对象，从下标2的位置返回4个，用cout<<对象.substr(2,4);可以打印出来2下标的4个

	交换：	对象.swap(对象2) 把对象的子串和对象2的交换

	运算符重载：输入 输出  >>  <<
		下标运算是：  [ ]
		赋值：+=   =    
		比较： 上面有那6个
		计算：  +    ： (对象1+对象2)。他他俩相加，对象1在前，也可以加字符串：("hello"+对象) hello对象，（hello在前哦），可以一下加好几个

迭代器：	关键词：iterator
	返回头的	定义：iterator关键词   定义是 string :: iterator 变量名a（迭代器名字）a前面就是类型，a就是自己定义的名字是，跟int a一个原理
		理解：就相当于一个指向string对象元素的指针（本质相当于一个char*的指针）定义完了 就跟指针的用法是一样的了 char* a指向对象首地址是：a=对象.c_str()，用这个函数就可以了，和迭代器有点差别
		遍历：变量名a=对象.begin(); 就指向了他的首地址，begin()这个函数就是返回字符串的首地址。用for(int i=0;i<对象.size();i++){ cout<<a[i];  } 这样就遍历了，size()函数还记得吧，他的类型是无符号整形，最好把int i；下面看
			 也改成size_t，是宏定义意思就是无符号整形，也可以在 for循环中{  cout<<*a; a++; } 这个样子遍历，都一样
		
	返回尾的迭代器：end() 函数，返回一个迭代器，指向字符串的末尾（最后一个字符的下一个位置）	
			用上可以遍历：for(a;a!=对象.end();a++) { cout<<*a; }在a第一个条件指向头，然后只要指针没有指向尾巴，就一直++循环，end()返回的是最后一个元素的下一个位置（应该是'\0'）
		
	通过迭代器赋值：通过*a 赋值，循环什么的还是一样 就是加了一个 *a='a',把对象原有的全部赋值成a，可以把循环改成i 赋值多少个a循环几次（前面那个循环结束以后a就指向尾巴了，可以重新用begin()赋值），不但可以用*修改，也可以通过下标运算修改
		定义和指针是不一样的，用法和指针一样， 为啥不定义成 char*啊，因为我们这个迭代器是要跟算法链接的，它适用于所有的容器，即，一个通用类型的指针，或者类似 叫智能 指针，
	迭代器失效：string重新申请空间的时候，迭代器会失效的，就是在申请的时候是15个空间 在增加的用函数强迫加空间时候会重新申请，但是迭代器还是指向的15个空间，这时候迭代器就失效了
	防止这种情况发生就要在使用一下 a=对象.begin(); 这样就行了，失效了就要重新赋一下值

	string成员函数 涉及到迭代器的：	1）begin() 返回首个元素。。2）end( )返回一个迭代器，指向字符串的末尾（最后一个字符的下一个位置） 
		3）尾插入：append可以用来任意位置在尾巴插入 对象.append(对象2.begin()+0,对象2.begin()+5),在后面插入对象从0到5个字符，可以改变加的数字插入的字符
		4）删除：erase 删除   对象.erase(对象.begin()+2) 就是删除的2个下标元素，对象.erase(对象.begin()+2，对象.begin()+5)就是删除2.3.4的
		5）插入：insert 插入 上面插入就是直接插的，这是用迭代器，对象.insert(对象可以是自身哦 . begin()+2,3,'a')在下标2的位置插入3个字符a 
			对象.insert(对象 . begin()+2，对象2.begin()，对象2.end())这样就把对象2的整个字符插入在了对象的下标2的位置，对象.insert(对象 . begin()+2，对象2.begin()，对象2.begin()+4) 就可已插入一段了
算法头文件：
	#include<algorithm>	
string与算法：遍历函数：	for_each(对象.begin()，对象.end()，函数名字) 函数的参数是char，因为容器的元素是char。这个是从头开始遍历，每一个都吧字符传递给函数，可以用函数处理（函数可以接受直接打印），一直到结尾. 如：函数：void f(char c){ cout<<c;} 
			也可以对函数封装修改 加返回值返回了什么的，但是改变了他的本意，看自己调用了。最关键的就是参数必须是容器元素，就是char 都是字符
	排序函数：	1）sort(对象.begin()，对象.end()) 从对象头到尾按abcd的顺序依次排序。默认从小到大排序，也可以begin+2从2去排序，后面排序到哪里也可以改变
			2）sort(对象.begin()，对象.end()，greater<char>()) 从大到小去排列，greater是一个仿函数（针对stl的特性） (目前未知)            <char>因为是char类型的
			
数组： 能用第一个就用第一个vector容器
1）vector容器： 头文件还是#include<vector>容器名，
	定义：	向量（动态数组）就是内存的动态分配（内存不够自己会申请）。内存分配原理和string一样的，是连续空间，空间不够自己申请更大的连续空间，同时迭代器失效
	形式： 	vector<int> 名字； 如果想用数组元素装int 就是int，记得加<>跟对象模板一样 。这就是vector的对象。string为什么没有<>因为他是专门针对char的
	参数列表：1）容器的数据类型（想让他装什么就是对应的类型<>在这里面定义）2）类型种类，基本类型int..如果是char本质上就和string一样了，没必要是char，还有结构体（直接放结构体名字，名字就可以代表全部了）
		指针（<int *...>），对象，普通对象（跟结构体本质是一样的<直接放类名>）和容器的其他对象<可以直接放一个string>然后vector的每一个元素都是一个字符串了
成员函数：	构造函数：1）无参构造：vector<int> a 这就是无参数的构造，没有元素用下标运算会崩溃
			2）有参数：  vector<int>a(5); 申请了5个有效元素，每个元素都初始化为0，输出用下标：cout<<a[0];，越界会崩溃
			3） vector<int>a(5,12)；申请了5个有效元素，每个元素都初始化为12；
			4）vector<int>a1(a);用一个vector对象给另一个初始化，跟拷贝构造函数一样（类型不同就报错，就是<>这里面的类型）
	定义一个迭代器	5）vector<int>::iterator a=a1.begin(); (string就是<>没有这个),让迭代器a指向a1对象的头，（a的本质就是<里面定义类型的*>）   vector<int>::iterator a2=a1.end(); 指向尾了（最后一个元素数据，string是最后一个的后一个）
			       vector<int>A(a,a2); 把a和a2的迭代器的值给了A，

	查看容量：	对象.capacity()查看容量大小，默认值是0，定义对象初始化的时候是几个，容量就是几个
	容量不够自动增加：	增加容量函数：对象.push_back(1 )；在后面加入一个元素1。 容量不够是增加容量是增加当前的一半（就是1.5倍），是10就增加5就是15，是13就13/2=6，就是18，要在容量满的时候增加才有用 （vc6.0有点不一样，是*2）

	自己修改容量;	对象.reserve(10)如果当前容量比10大就是10，没有10大就是增加1.5倍，就是上面那种增加。 重新分配后，迭代器会失效 ，如果需要空间很大可以预留不然系统一次次的加效率低
		大小	1）对象.size(); 返回容量个数，当增加容量后他会增加，但是元素还是不变 
			2）对象.resize(3); 重新设置元素个数，容量不变，就把元素的个数设置成了3，容量不变 如果变小 就把后面的截断
			3）对象.empty();  判断是否有元素，如果有元素返回0，没有返回1

操作：	
	赋值：会覆盖	1）对象.assgin(5,10)赋值5个10
			2）对象.assgin(对象2.begin(),对象2.end());用迭代器赋值，可以任意那一段赋值，

	查：输出：1）输出单个：1）循环打印 用 a [i ]下标，2）把下标换成 at(i)和下标基本一样，就是at()可以用异常抛出什么的，3）对象.back()返回尾巴，就是最后一个元素，4）还有就是begin返回头元素
		2）输出全部：1）循环下标[ ]   2）迭代器  ：vector<int>：:iterator a=对象.begin(),然后就可以循环了 for(a;a!对象.begin();a++){  输出是 cout<<*a<<endl; }
		有算法头文件：	3)函数：for_each(对象.begin()，对象.end(),函数名f)    函数是自己定义的0  void f(int a) 参数要和<>这个一样 {  cout<<a; }   可以对他输出，也可以干点别的
	
	曾：尾添加：对象.push_back(1)在后面添加一个1，()是放什么值添加什么
	       中间添加：对象.insert(对象.begin()+2,10) 在下标为2的位置添加一个10		
			对象.insert(对象.begin()+2,10，2)在下标为2的位置添加10个2
			对象.insert(对象.begin()+2，对象2.begin()，对象2.begin()+5)在对象下标2的位置插入 对象2从下标0开始到下面5前面的一共是5个（如果最后一个参数是end(),就把对象2 	全部插入）
		有一点小区别：由于是数组他的尾添加效率非常高，不考虑重新增加时间，中间添加的就很低了，
	
	删：尾删除：对象.pop_back(); 删除最后一个元素数据，在调用一次又删一个
	     指定位置删除：对象.erase(对象.begin()+2)就删除下标是2的元素，
			对象.erase(对象.begin()+2，对象.begin()+5)就是删除2.3.4的  后面参数end()，就是从2后面都删除了
	   删除所有：对象.clear(); 删除所有元素，不加入在调用就是崩溃

	改：可以用循环，就是刚才输出用的循环，加上赋值，还有at()也一样，还有 [ ] 下标运算

交换两个向量的内容：对象.swap(对象)；就把两个对象交换了
		这个也可以收缩空间 用对象.resize 这个只能改大小 容量还是原来的 然后 vector<int >(v).swap(v); 原理是申请一个匿名对象和他来交换了 然后长度变成匿名对象的了 
			匿名对象已用完自己就释放了
	可以按区间查找： find_if(begin,end,仿函数)  仿函数实现 如：查找区间 形参int a  return a>5 。函数返回迭代器大于5的位置 

运算符重载：  等于 不等于 大于小于 大于等于 小于等于，还有下标运算符，[ ] 就用呗 数组下标
	比较：比较两个向量的大小，正确是1，错误是0。和字符串比较是一样的 都是一个一个的比较
	
算法：	头文件还是那个 #include<algorithm>
	遍历：就是查 的第3个 for_back这个函数；
	排序：1）sort(对象.begin()，对象.end()) 从小到大去排列（和string一模一样），也可以begin+2从2去排序，后面排序到哪里也可以改变
		2）sort(对象.begin()，对象.end()，greater<int>()) 从大到小去排列，greater是一个仿函数（针对stl的特性） (目前未知)<>是放类型的	可以begin+2从2去排序，后面排序到哪里也可以改变
	乱序：random_shufflie(对象.begin()，对象.end())两个迭代器， 把里面的数据打乱，但是每次打印都一样， 记得种种子不然都是一样的
	 不一样：就要在加一个函数了，srand((unsigned int)time(0));  time函数的头文件是 <ctime>  就是随着时间变化来去随机值，先强转成无符号整形，在用时间随机
	
2）array容器：是固定的空间（固态数组）.vs2005暂不支持有很多编译器不支持	还没有vector好用，就都用vector了

3）valarray ：属于数学计算的一个，它里面主要是<cmath>的函数封装的。 知道吗？在c里面是<math.h>

链表容器：
1）list容器：本质是双向链表，比单向多了一个指向前方的指针，
		与vector的区别：他的随机访问快，下标运算说是那就是那，尾添加，不申请内存非常快，不支持快速插入和删除，比较慢
		list：不支持随机访问 没有下标，支持快速插入和删除	。他俩就是链表和数组的区别
	list头文件：就是<list>
	定义：list<类型>变量名；  如：list<int >a; 
	类型种类：和vector一样
	构造函数：无参数构造：list<Node>a;  结构体类型的哦
		有参数：1）list<Node>a(5); 就是定义了5个元素 都初始化为0结构体内所有成员
			2）list<Node>a(5，结构体变量no); 就是定义了5个元素都赋值成 no的值   Node no={12,13.2f };
			3）list<Node>a(a1); 用另一个容器对象给这个赋值
			4）list<Node>a(a1.begin()，a2.end()) 赋值另一个对象的元素的从哪里开始，用迭代器，只能++运算，不可以直接+1+2
	
	定义list迭代器：list<Node>::iterator 变量q  。 可以使用q++（不可以进行加法运算）;++后就指向了下一个位置了，结构体就是一下个节点
	容量：对象.resize(3)截断容量， 没有容量这个概念,设置多大他就是多大 可以用size()查看 

	大小：对象.size(); 得到元素的个数
	修改大小：对象.resize(3)元素大小都变成3了	 变大 可以第2参数指定值，变小就删除了
	测试是否有元素：对象.empty(),元素返回的是0没有元素返回的是1

	查: 输出全部：1）循环：申请一个迭代器a，然后赋值对象.begin(),然后用for(a;a!=对象.end();a++){打印 a->成员}
		2）打印：for_each(对象.begin(),对象.end(),函数名) 和上面一样用f用，把每一个节点的参数传过去操作，那边就是单个输出每一个结构体成员
	      输出单个元素：list不支持下标，1）尾、对象.back().成员变量，back是返回最后一个成员的引用，因为是结构体最后一个成员是一个结构体 ，所以用.打印出来要输出的成员  如：对象.back.a；a是成员1还有别的成员就这样的形式
				2）头、对象.front() 和上面的使用方式都是一样的，上面是尾下面是头

	增：1）头添加：对象.push_front(Node(12,12.3f))   因为类型结构体（是特殊的类），所以在结构体里创建一个构造函数（就是把结构体当类使用了）结构体中：Node(int a,float b){ 成员1=a；成员2=b; }   
			创建好了构造函数就不可以用 Node a={12,13.2f}这样子赋值了，就要用构造函数赋值了
	2)尾添加：对象.push_back(Node(12,12.3f) )  和头添加一样 ,测试的时候就把尾当成头了，用法一样
	3）中间添加：跟vector是一样的，1）对象.insert(迭代器，(Node(12,12.3f ) ) 记住创建迭代器的时候可以早点创建，记得赋值以后要重新给迭代器指向对象.begin(),不然迭代器++会崩溃
 				2）对象.insert(迭代器，3，(Node(12,12.3f ))  再迭代器的位置插入3个元素	
				3）对象.insert(迭代器，对象2.begin()，对象2.end())，迭代器记得指向对象.begin()（不可以begin+1不能用+，只可以++，还有--），在迭代器的位置插入对象2全部的数据

	删：1）尾删除：对象.pop_back(); 就是直接删除尾巴的一个元素
	  2）头删除：对象.pop_front()；就是直接删除一个头元素
	3）删除指定元素：1）删除一个：对象.erase(迭代器) 用迭代器表示位置，  迭代器只能++运算，也可以--。( )可以放迭代器.--end()  因为end()是最后一个元素的下一个 -- 刚好是尾节点
			2）删除一段：对象.erase(迭代器，迭代器2) 两个迭代器之间的位置，从第一个开始一直删除到迭代器2前面的那个 
  			3）全部删除：对象.clear()	
			4）删除所有跟参数相同的元素：对象.remove(Node(14,15.5f))就是删除所有的Node(14,15.5f)和她一样的，要在结构体内定义一个==的函数重载（因为要判断）
				结构体内：bool poerator==(const Node& a){   if(a.成员1==this->成员1&&成员2，成员3) return true；不满足 return false；}
			5）删除list重复的：对象.unique(Node(14,15.5f))
	改：1）利用迭代器修改：构造函数和增加
	   2）赋值：对象.assign(3，(Node(12,12.3f ))重新赋值，覆盖掉，3个(Node(12,12.3f )元素
		对象.assign(迭代器，迭代器2 ) 把 另一个对象的迭代器的一段覆盖过来
	3）=  ：list重载了等号运算符，一个对象=另外一个对象

其他:	 1）交换两个list的内容： 对象.swap(对象2) 交换内容
	2）把list元素全部倒转：对象.reverse();	把里面的元素倒转	
	3)排序函数：	对象.sort()跟算法中的这个排序不一样（list有这个函数就不用去算法里面的了），默认从小到大，这个也要运用判断 <也要自己写重载
			 也要在结构体里面写运算符重载（自己设置，一个小于，两个成员小于才符合）增加的删除4 的时候有==参考，（可以在函数中设置< ||  >来按照是从大到小还是从小到大）
	4）合并两个list：对象.merge(对象2) 自动排序，两个链表必须有序，哪有涉及到运算符重载了，定义还是上面一样，如是无序的先调用一下排序sort。两个从小到大的排序，定义重载的时候函数里要写大于，从大到小写小于
	
	拼接：1）对象.splice(迭代器的位置，另一个对象)插入到迭代器的位置
		2）对象.splice(迭代器的位置，另一个对象，另一个对象的迭代器位置)把对象中的某一个节点插入到迭代器位置
		3）对象.splice(迭代器的位置，另一个对象，另一个对象的迭代器位置，另一个对象的迭代器位置) 把另一个对象 这两个迭代器的一段出入进去
	
运算符重载：  等于 不等于 大于小于 大于等于 小于等于，还有赋值运算符，= 就用呗 。跟vector一样（一个是=一个是[ ]）

算法：头文件#include<algorithm>
	遍历：上面的一样
	排序也是
	翻转链表：对象.reverse()
	查找函数：list<Node>iterator 变量名a=find(迭代器，迭代器2，查找的值)就是两个迭代器中间的这一段找这个值。找到之后（没找到崩溃）定义一个接收一下，然后打印出来，cout<<a->成员1<<" "<<a->成员2...<<endl;,
这个没讲
2）forward_list容器：单向链表，向前链表，操作都在表头（不是所有编译器都支持）

双端队列：

deque：队列：	参考上面的函数用法： 构造一样 <deque> 没有容量这个概念 
			 push_front()头插、 pop_front()头删、  insert()插入  push_back()尾插 pop_back()尾删 还有迭代器
			clear()全部清空 erase()删除区间 
			assign() 赋值、empty() 是否为空、size() 大小 、resize() 指定长度 短了删除 长了可以第二个参数填充值
	对比vector和list来理解学习，头文件还是本身<deque>  创建对象还是  deque<> 对象，创建迭代器 deque <>::iterator 变量名a=对象.begin()，a是指针哦
	内存比较：deque是段连续空间，好多段连续空间，然后把好多段链接起来，哪两个一个是数组空间，一个是节点空间，不用说了
	
	功能比较：vector：他的随机访问快，下标运算说是那就是那，尾添加，不申请内存非常快，不支持快速插入和删除，比较慢，不建议头添加
		list:随机访问慢 也支持下标，支持快速插入和删除	支持头添加、尾添加
		deque：随机位置插入删除效率不高。但是高于vector低于list（取决于数据量512bit）支持随机访问比vector慢，支持头添加和尾添加，
	 
	使用选择：
		随机访问操作频率高，就用vector
		插入删除频率高，头尾添加，就用list
		随机访问+头尾添加就用deque，他比vector多头添加比list多随机访问。迭代器复杂
	
	函数对比：只需要对比vector：没有capacity（得到容量）和reserve（重置容量）
				多了：pop_front和push_front。多了头删除和头添加。其他的都一样了

上面都是顺序容器
关联容器：1）有序容器：插入的时候有个排序的功能，迭代器和list一样，只可以++ 不可以直接+5这种
map：键值对：不允许重复，底层是红黑树，有空记得了解
		特点：键值不可以重复，高效访问，对比list 一百万个数据他1~20次就可以找到，插入效率低于链表（因为涉及到排序），数据少就list，多就map
		红黑树：平衡排序二叉树：反正就是很多数据的时候很快，1百万查找才只用1~20次
	
	构造函数： 可以用typedef 重命名pair<int,char>使用的时候方便 为in_pair(随便起的 )
		pair<int,char> 对象(1，'a');

	键值：pair<定义写的类型> 在用for_each打印的时候函数接收参数的时候是  pair<>类型 变量a （不要加&，别的容器都有）， 打印是 cout<<a.first(这个是键值)<<a.second(这个是实值)
		键值：first  a.second(这个是实值)..不可以重复  pair<键，实>
	无参：	map<int,char>变量名a;   前面int是键值（因为排序整数方便也可以放别的），char是实值（什么都行结构体啥的都OK），先用这两个代替一下

	插入	1）对象.insert(pair<int,char>(1,'a'))  插入了一个键值对， pair是一个键值组合来插入<>z这个里面的要和定义的时候一样，后面是()放值。 可以用typedef 重命名pair<int,char>使用的时候方便 为in_pair(随便起的 )
			就可以 对象.insert(in_pair(2,'a')) 数字是键值，不能一样，实值可以相同,。键值相同加插入不进去（会自动排序的）可以用返回值查看是否插入成功，返回值这个不太懂：c3stl网易27||28p
		2）对象.insert(迭代器，pair<int,char>(5,'a'))  键值不可以一样，就算是在你想要的位置插入，他还是会自动排序到它该去的位置。 迭代器和list一样，只可以++ 不可以直接+5这种
		3）对象.insert(对象2.begin(),对象2.end());  插入对象2的所有元素，都是迭代器可以选择插入那一段，也是会自动排序
		4）用对象给对象直接初始化，类的构造函数那种，如  对象1是已经申请好的，：map<int,char> 对象2(对象1)，就是这样，也可以直接申请后赋值，对象2=对象1
		5）也可以用上面构造初始化的方式在升级一下：map<int,char> 对象2(对象1.begin()，对象1.end()) 两个迭代器可以++ 什么的
	不管什么时候去插入或者如何插入 他都是自动排好序的，用键值
		6) 对象[1]='a'; 	不建议这样插入  可以用它来找 例如:cout<<对象[1]<<endl;
		7) 对象.insert(make_pair(2,'a')); 这个方便简单一点
		8）对象.insert(map<int,char>::value_type(3,'a'));

	属性：	容量：和list一样没有容量这个概念
		个数：对象.size()；打印出元素个数
		得到一个元素，判断是否存在：对象.count(2)2是要找的键值，找到返回1 找不到0
		判断是否为空：对象.empty();  空为1，非空为0
	
	输出：1）for_each(两个迭代器一个函数名)，记得加头文件#include<algorithm>
		2）用迭代器for，迭代器a指向对象b的头，然后for(a;a<b.end();a++){  cout<<a->first（键值）<<a->sound（实值） } for()中的迭代器是可以++的不是非要从头开始，也可以一段，先循环++到那一段然后在打印，end()可以--
		
		没有提供头添加头删除啥的，因为自动排序在哪里插入都一样
	修改：循环可以输出，也可以修改，用迭代器自加自减也可以，键值是不可以修改的（因为是顺序二叉树一改不就乱了吗）
	
	删除：1）对象.erase(迭代器) 删除迭代器所在位置的节点
		2）对象.erase(迭代器，迭代器) 删除两个迭代器中间的一段
		3）对象.erase(1)通过一个键值删除一个元素数据
	删除所有元素：对象.clear(); 一键回到解放前

	其他函数：查找： 迭代器=对象.find(1)，1是键值，没有重载，只能通过键值查找。 返回类型是迭代器，找到返回，然后通过迭代器输出，输出的时候记得迭代器是指针，分别输出键值和实值
			可以直接 对象.find(1)->first||second，单个输出键值或者实值，找不到崩溃，但是找不到==end(),可以用if(崩溃==end()){输出试试}，可以得出没有找到崩溃，为元素下一个，即end()尾迭代器
			迭代器！=对象.end() 就是查找到了 用迭代器解引用的方式来的到key值和 value的值  *迭代器
		统计：count(key);  返回int类型 有就返回1 没有就死0  因为只有一个key值  	
		交换：对象.swap(对象2)；两个容器的内容全都变了交换了
		排序：默认是从小到大；sort() 这个是自动的 自定义类型要 自己写排序规则（类重载() ）
		 从大到小：在定义对象的时候写一个仿函数greater<类型>()（小圆括号就不加了，因为是类型，上面的sort是要实参）。如：map<int,char,greater<int>> 变量名，记得加仿函数的头文件#include<functional>
		
		对象.lower_bound(2)键值2，返回键值2的>=他的第一个，如果有2就是返回本身=，如果没有就是返回>=第一个。不可以直接打印，因为返回的是一个迭代器，可以用迭代器接收一下打印也可以：对象.lower_bound(2)->first || second	
		对象.upper_bound(2) 键值2，跟上面一样，就是他只  >  不等于哦
	算法里面也有：	equal_range()  不懂去查百度吧

multimap：操作函数跟map都一样，头文件也是 <map>
	区别：	1）可以有重复键值，map不行
		2）计数：count()在map是 存在返回1，不存在返回0，判断是否存在，
		再multimap中是判断 值的个数的是几个，没有就返回0
		3）find() 他是返回第一个匹配的元素，没找到返回最后一个(应该是键值匹配到的时候吧）后面这句没讲
		
set:键值和实值是一样的，只有一个，不允许重复，只有一个元素，还会自动排序，就是实值！' 剑' 就是实
	特点：和map一样 
	形式：set<string> 对象；  用一个对象试试,用到string的时候 想到加头文件了吗？不加可不行呀
	  会排序，string就是字符串比较大小，然后排序，从大到小 去看上面map写的有
	插入一下吧：对象.insert(string("abc"))  也是会自动排序的。重复插入不可以一样，用对象的类型和int 啥的都一样，insert()里的是string的插入，换汤不换药

	迭代器：set<sting>::iterator 名字 =对象.begin()   也是只可以自加自减 不可以+4 +5什么的
	属性：和map一样
	
	输出：和map一样，迭代器自加减，或者循环 ||  for_each

	增：insert()
	改：键值不可以改实值可以，这个是一个能不能改呢？改了树不就变了，要进行修改
	删：也是一样 对象.erase(string("asd")); 如果想吧string去掉：对象.erase("asd")，可以直接这样，因为string里已经有重载了，不然就要在string写上运算符重载了
	查：find(1) 若1存在返回该元素的迭代器  若不存在 返回 end()
	
	自定义类型要 指定排序规则  不然插入不知道怎么弄：仿函数本质是类
		例如：	class a{public: bool operator()(const 自定义的类型T&a , const T&b){return a.name>b.name}};
		然后创建set的时候吧 a这个类也穿进去 set<T,a> p;让他知道怎么自动排序 别的模板也是一样的 自定义类型要告诉他们怎么排序 才可以使用sort .
		这个不告诉他就插入不了数据


	muitiset：允许重复
	统计个数 计数：count和muitimap一样
	2）无序容器：


				c3 完结了








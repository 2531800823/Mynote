#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#include<stdlib.h>
typedef struct Node
{
	int data;
	struct Node* next;
}node;

node*create(int n)
{
	node* p = NULL;
	node* head = (node*)malloc(sizeof(node));
	head->next = NULL;
	p = head;  //让p指向第一个空头
	node* s=NULL;
	int i = 1;
	if (0 != n)
	{
		while (i <= n)
		{
			s = (node*)malloc(sizeof(node));
			s->data = i++; //当第一次为空的时候 s->data = 1，然后依次曾加1
			p->next = s;  //成为第一个节点
			p = s;  // 把s的位置给p，p指向下一个节点
		}
		s->next = head->next; //循环结束s->next指向头节点，head->next指向第一个有数据的节点，赋值给s->next
	}
	free(head);   //释放空头，已经没用了，占内存
	return s->next; //返回头节点，s是为节点，指向头节点，循环链表尾指向头
}


int main(void)
{
	int n = 41;
	int m = 3;
	int i;
	node *p = create(n); //接收返回的头节点
	node* temp;

	m %= n; //m=m%n;这个意思=3

	while (p->next != p)
	{
		for (i = 1; i < m-1; i++)//循环1次
		{
			p=p->next;  //p变成了第二个几点
		}
		printf("%d->", p->next->data); //打印出第三个节点的值
		temp = p->next; // 把第三个节点给temp 
		p->next = temp->next; //让指向第四个节点
		free(temp);  //把第三个节点删除
		p = p->next;  //跑变成第四个节点
	}

	printf("%d\n", p->data);//打印出剩下的那个节点
	printf("%d\n", m%n);

	 system("pause");
	return 0;

}
#include<stdio.h>
#include<stdlib.h>
typedef struct Node
{
	int data;
	struct Node* next;
}STU;
//新建一个节点
STU* createNode(int data)
{
	STU* newNode = (STU*)malloc(sizeof(STU));
	newNode->data = data;
	newNode->next = NULL;
	return newNode;
}
typedef struct Queue
{
	STU* frontNode;
	STU* tailNode;
	int size;
}Liu;
//创建一个队列
Liu* createmyQueue()//创建一个队列
{
	Liu* myQueue = (Liu*)malloc(sizeof(Liu));
	myQueue->frontNode = myQueue->tailNode = NULL; //初始化，头节点等于尾节点等于空
	myQueue->size = 0;
	return myQueue;
}
//入队
void push(Liu* myQueue, int data)
{
	STU* newNode = createNode(data);
	if (myQueue->size == 0)
	{
		myQueue->frontNode = myQueue->tailNode=newNode; //为空时头和尾都指向新建的
	}
	else
	{
		
	
		 myQueue->tailNode->next = newNode; //尾的后面的那个节点指向新建的
		myQueue->tailNode = newNode;//让尾指向最后一个
	}
	myQueue->size++;//元素加1 
}
//出队
void pop(Liu* myQueue)
{
	if (myQueue->size == 0)
	{
		printf("空对");
			return;
	}
	else
	{
 		STU* nextNode = myQueue->frontNode->next;  //把头节点的下一个节点给新的代替
		free(myQueue->frontNode);  //释放头节点
		myQueue->frontNode = nextNode;  //把新的节点代替的给头节点，让头节点重新指向头
		myQueue->size--;
	}
}

//获取对头元素
int front(Liu* myQueue)
{
	if (myQueue->size == 0)
	{
		printf("空对");
		return myQueue->size; //当值为空的时候，返回0
	}
	else
	{
		return myQueue->frontNode->data;  //返回头节点的第一个元素
	}
}
int empty(Liu* myQueue)
{
	if (myQueue->size == 0)
		return 0;
	return 1;
}
int main()
{
	Liu*myQueue = createmyQueue();//创建的队列给新建
	push(myQueue, 1);  //入队
	push(myQueue, 2);//入队
	push(myQueue, 3);//入队
	push(myQueue, 4);//入队
	while (empty(myQueue))//万金油判断队列是否为空
	{
		printf("%d  ", front(myQueue)); //打印头节点元素
		pop(myQueue);  //出队一个，好让头节点元素一个一个打印，最后出完尾0.循环结束
	}


	system("pause");
	return 0;

}
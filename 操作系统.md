# 操作系统

### 进程和线程的区别

> 1. 进程是CPU资源分配的最小单位，线程是CPU调度的最小单位
> 2. 进程有独立的系统资源，同一进程的线程共享大部分资源(堆、代码段、数据段)，每一个线程值拥有一些在巡行中必不可少的私有属性比如：tcb、线程id、栈、寄存器
> 3. 一个进程崩溃，不会影响到其他进程，线程崩溃会让同一进城内的其他线程杀死
> 4. 进程在创建、切换和销毁时开销比较大，线程小，
>    1. 进程创建的时候需要分配系统资源分配，销毁的时候需要释放系统资源
>    2. 进程切换分为两步：切换页目录、刷新TLB使用心得地址空间；切换内核栈和硬件上下文（寄存器）
>    3. 线程：逻辑地址是是一样的，不需要切换页目录，刷新TLB

### 进程和线程的使用场景

> **多线程模型:**
>
> 1. 主要优势为线程切换代价小，因此适用于I/O密集的工作场景，因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁切换线程，
> 2. 多线程也适用于单机多核模型
>
> 多进程模型：
>
> 1. 多进程模型的优势是CPU，适用于CPU密集型，同时，多进程模型也适用于多集分布式场景中，易于多集扩展

### 死锁的产生和解决

> **产生死锁的条件**
>
> 1. ​	互斥性：一个资源每次只能被一个线程调用
> 2. 请求和保持条件：一个线程对请求被占有资源发生阻塞，对已经获取的资源不释放
> 3. 不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用
> 4. 循环等待：发生死锁时，线程进入死循环，永久阻塞
>
> **原因**
>
> 1. 竞争不可抢占性资源 
>    1. A在上海等B，B在北京等A，他俩都是等不到不走
> 2. 竞争可消耗资源引起的死锁
>    1. 程间通信，如果顺序不当，会产生死锁，比如p1发aa给p2, p1接收p3的消息cc,p2接收p1的aa,发bb给p3, 以此类推，如果进程之间是先发信息的那么可以完成通讯，但是如果是先接受信息就会产生死锁
> 3. 进程推进顺序不当
>    1. 进程在运行过程中，请求和释放资源的顺序不当，也会导致进程死锁
>
> **避免死锁的方法**
>
> 1. 破坏 请求和保持 条件
> 2. 破坏 不可抢占 条件 
>    1. 如果去抢资源，没抢到就 释放自己的资源，操作系统允许抢，只要优先级够大
> 3. 破坏 循环等待 条件
>    1. 申请必须按照资源的编号顺序提出

### 进程间的通讯方式

> 1. 管道
> 2. 消息队列
> 3. 信号量
> 4. 信号
> 5. 共享内存
> 6. 本地套接字
# C++语言面试

### C、C++的区别

> 1. **设计思想上**
>    1. C++是面向对象的语言，C是面向过程的结构化编程语言
> 2. **语法上**
>    1. C++具有封装性、继承、多态三种特性
>    2. C++相比C，曾加许多类型安全功能，比如强制类型转换
>    3. C++支持范式编程，比如：模板、函数模板，运算符重载

### 说一下static关键词的作用

> 1. #### 全局静态变量
>
>    定义：前面 + static
>
>    生存周期：程序结束，在静态存储区 
>
>    初始化：自动初始化为 0  
>
>    作用域：从定义开始，到文件结尾，别的文件不能用，让外部文件访问加extern
>
> 2. 局部静态变量
>
>    定义：前面 + static
>
>    生存周期：程序结束，在静态存储区
>
>    初始化：自动为0
>
>    作用域：仍是局部作用域，当前函数结束作用域没有结束,下次在来这个作用域，他的值不变。
>
> 3. 静态函数
>
>    默认是extern的但是只是声明不能被其他文件可使用
>
> 4. 类的静态成员
>
>    是所有对象的共享成员，不是某个对象的。
>
> 5. 类的静态函数
>
>    和静态成员一样，不属于任何一个对象，不可以直接调用非静态成员，因为没有this指针，调用格式
>
>    类名::静态函数名字(参数)

### struct和class的区别

> struct访问权限默认是public的
>
> class默认是私有的private的 

### new和malloc的区别

> 1. new和delete是关键字，malloc和free是库函数
> 2. 使用new申请内存分配时不用指定内存大小，编译器会自己计算，malloc需要显示的指出所需内存的大小
> 3. new分配成功时，返回的是对象类型的指针，类型严格要求，不用类型转换，是符合类型安全性的操作符，malloc分配成功先返回void*，需要强制类型转换成我们想要的类型
> 4. new内存分配失败时，会抛bac_alloc异常,malloc分配失败返回NULL
> 5. 因为new和delete可以重载
> 6. new会先调用operator new 函数然后调用构造函数，delete先调用析构函数，在释放内存，malloc和free不会调用构造和析构
> 7. 内存泄露new和malloc都可以检测出来，new可以指出来是哪个文件的哪一行，malloc不可以

### 指针和引用的区别

> 1. 指针有自己的一块空间，引用只是一个别名
> 2. 使用sizeof指针的大小是4，引用则是被引用对象的大小
> 3. 指针可以被初始化NULL，引用必须被初始化且必须是一个已有对象的引用
> 4. 作为参数传递时，指针需要被解引用才可以操作，引用就可以直接操作修改
> 5. 可以有const指针但是没有const引用
> 6. 指针在使用时可以指向其他对象，引用只可以是一个对象的引用，不可以改变
> 7. 指针可以多级指针，引用只可以1级
> 8. 指针 ++操作和引用的 ++ 操作意义不一样
> 9. 如果返回动态内存分配的对象或者内存，就要使用指针了，引用容易引起内存泄露

### 四种类型转换

> 1. ###### **const_cast<>()**
>
>    用于const转换非const
>
> 2. ###### **static_cast<>()**
>
>    用于各种隐试转换，非const转const，
>
>    也可以用于多态向上转换，如果向下能成功，但是不安全
>
> 3. ###### **dynamic_cast**
>
>    用于多态类型转换，只用于含有虚函数的类，可以向下或者向上转换，只可以转指针和引用，如果非法指针返回NULL ， 引用抛异常，
>
>    向上转换：子类是转父类
>
>    向下转换：父类转子类（父类指针指向子类对象）
>
> 4. ###### **reinterpret_cast<>()**
>
>    几乎什么都可以转，比如int转指针，但是会出现问题，尽量少用
>
> 5. **为什么不用C语言的强制类型转换**
>
>    **C的强制转换看着很强，什么都能转，但是转换不够明确，不能进行错误检查，容易出错**
>
>    

### C++中的四个智能指针

> - ​	C++里有4个智能指针， auto_ptr 已经被C++11弃用
> - 为什么用智能指针：申请空间忘记释放
>
> 1. **auto_ptr**
>
>    ```c++
>    auto_ptr<string> q1 (new string("hello"));
>    auto_ptr<string> q2 ;
>    q2 = q1; //auto_ptr不会报错
>    //当当前程序运行时访问 q1 程序会报错。 缺点： 存在潜在的内存崩溃问题
>    ```
>
> 2. **unique_ptr ( 独占式 )(替换auto_ptr)**
>
>    ```cpp
>    //实现独占式，保证同一时间只有一个智能指针使用
>    unique_ptr<string> p1(new string("hello"));
>    unique_ptr<string> p2;
>    p2 = p1;	//此时会报错，因此unique_ptr比auto_ptr更安全
>    //还有当程序试图将一个unique_ptr赋值给另一个时，unqiue_ptr是临时右值，允许，
>    //unique_ptr如果存在一段时间就不允许，比如：
>    unique_ptr<string > p3;
>    p3 = unique_ptr<string>(new string("hello"));
>    //如果想要 p1 赋值给 p2 可以用std::move操作
>    p2 = std::move(p1);
>    ```
>
> 3. **shared_ptr（共享式拥有）**
>
>    ```Cpp
>    //可以允许多个指针指向一个对象，使用计数机制，当最后一个指向的引用销毁才释放
>    //除了通过new 还可以 auto_ptr来构造
>    //成员函数
>    //使用release()，可以释放所有的权限 好像是直接把所有置空
>    //use_count() 来查看资源的是所有者个数
>    //unique 返回是否是独占所有权（use_count为1）
>    //swap 交换两个shared_ptr 对象
>    //reset 将引用计数-1，停止对指针的共享，除非计数为 0 不然不释放
>    //get 返回内部对象（指针）因为重载了() 如：
>    	shared_ptr<int>sp (new int(1));
>    	sp 和 sp.get() 是等价的
>    ```
>
> 4. **weak_ptr(不控制生命周期)（指向一个shared_ptr管理的对象，不可单独使用）**
>
>    用来管理shared_ptr 的，不能指向原始指针，
>
>    将一个weak_ptr绑定到一个shared_ptr对象，不会改变shared_ptr的引用计数。
>    
>    ```CPP
>       
>    ```
>    
>    

### C++11的新特性

> 1. auto关键字：根据初始值自动进行类型推到，可以用  **decltype** 查 看
> 2. nullptr：可以被转换任意指针，当重载传递参数的时候，是指针，NULL是宏定义的 0 
> 3. 智能指针：shared_ptr,weak_ptr
> 4. 初始化列表：能在构造函数后面用 ：变量名() 方式赋值
> 5. 右值引用：：实现移动语义，完美转发，消除两个对象交互时不必要的拷贝
> 6. 新增array：相当于数组
> 7. lambda表达式

### const用法和作用

> 1. ##### 修饰类对象
>
>    1. 常量对象只能调用常量函数，别的成员函数都不能调用
>
> 2. ##### 修饰普通成员
>
>    1. 可以在类型前和类型后，别修改成员的值
>
> 3. ##### const与指针
>
>    const放在类型前面表示指针指向一个常量，放在* 后面是一个常量指针
>
>    ```CPp
>    const int* p; //p指向的是一个常量
>    int *const p; //p是一个常量指针
>    ```
>
> 4. ##### const修饰函数参数
>
>    const不可以修改函数参数，起到保护的作用
>
>    ```c++
>    void foo(const int a)
>    {
>        a = 10; // 会报错
>    }
>    ```
>
> 5. ##### const修改类成员函数
>
>    表示函数不能修改任何成员变量的值，同时不可以调用任何非const的函数
>
>    ```c++
>    class demo
>    {
>    private:
>        int a;
>    public:
>        void foo()const
>        {
>            a = 10; // error
>        }
>    };
>    ```
>
> 6. ##### const修饰函数返回值
>
>    1. 函数指向常量的指针返回 const int* ：接收的返回值是：常量指针、指针变量、指针常量都可
>
>    2. 返回指向变量的常量指针 int* const 接收的可以是：变量指针、常量指针、指针指向变量|常量
>
>    3. 返回指向常量的常量指针 const int* const 接收的返回值：量指针，指针变量、指针常量第一个一样
>
>    4. 返回常量 const int 这种写const 没什么意义 因为都是复制
>
>       **总结前3：常量可以赋值常量和变量，指向常量的指针必须必须赋给指向常量的指针，指向变量的指针可以赋给指向变量或常量的指针**
>
>       ```c++
>       const char* foo()
>       {
>       	const char a = 'c';
>       	const char* p = &a;
>       	return p;
>       }
>        
>       char* const foo2()
>       {
>       	char a = 'c';
>       	char* const p = &a;
>       	return p;
>       }
>        
>       const char* const foo3()
>       {
>       	const char a = 'c';
>       	const char* const p = &a;
>       	return p;
>       }
>        
>       int main()
>       {
>       	//char* p = foo();	//error，指向常量的指针不能赋给指向变量的指针
>       	const char* p = foo();	//指向常量的指针
>       	const char* const p4 = foo();	//把变量指针赋给常量指针，合法
>        
>       	char* p2 = foo2();	//把常量指针赋给变量指针，合法
>       	char* const p3 = foo2();	//常量指针
>       	const char* p5 = foo2();	//指向变量的指针可以赋给指向常量的指针
>        
>       	const char* const p6 = foo3();	//指向常量的常量指针
>       	const char* p7 = foo3();		//指向常量的变量指针
>       	//char* const p8 = foo3();		//指向变量的常量指针，error
>       	//char* p9 = foo3();				//指向变量的变量指针，error
>        
>       	cin.get();
>       	return 0;
>       }
>       ```
>
>       
>
> 7. ##### const函数的健壮性
>
>    1. 修饰函数参数
>       1. 按值传递的参数加上const是没意义的，因为参数传递的时候是拷贝的。按引用传递时加上const保证传出参数的同时对象也不会被更改
>    2. 修饰函数返回值
>       1. 返回指向常量的指针只能用指向常量的指针接收，避免指针指向的对象被更改。
>    3. 修饰成员函数
>       1. 保护成员不被改变

### C++类中访问权限

> public : 公有访问
>
> protected：保护访问
>
> private：私有访问

### 重载和覆盖

> 重载：两个函数名字相同，但参数或类型不同，返回值没要求
>
> 重写（覆盖）：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数

### 虚函数和多态

> 多态的实现分为：静态多态、动态多态
>
> 静态多态：主要是重载，编译时已经确定
>
> 动态多态：是虚函数实现的 ， 父类指针指向子类对象的，在运行期间绑定
>
> 虚函数：有虚函数的类中，最开始的地方有个虚函数表指针，这个指针指向虚函数表，表中放了虚函数的地址(在代码段)，当子类继承会继承虚函数表，子类重写了父类的虚函数，虚函数表中的地址会变成重写的函数地址，使用了虚函数，会增加访问内存开销，降低效率。

### 为什么需要虚析构函数

> 析构函数一般都是释放内存的，析构不调用会造成内存泄露，实现虚析构是为了一个父类的指针指向子类对象时，释放的时候用来释放子类的内存的

### ++i和i++

```Cpp
int& int::operator++()// 有参数是i++,没有是++i
{
    *this += 1;
    return *this;
}
const int int::operator++(int) //++i 可以连续，因为返回的是引用，i++返回的是一个临时不可连续操作 如：++++i;
{
    int temp = *this;
    ++(*this);
    return temp;
} 
```

### map和set

> 都是关联时容器，底层都是红黑树，会根据key排序
>
> 区别：
>
> 1. map是key-value,set是key和value一个
> 2. map支持下标操作，set不支持
> 3. set的迭代器是const的，map是可以修改value，但key是const的

### resize和reserve的区别

> resize:改变容器含有元素的数量，不够这个的后面的值都变成0 ， push_back(1) 就在0后面
>
> reserve：改变当前容器的最大容量，不生成元素

### vector和list

> ##### vector:
>
> ​	连续存储的容器，动态数组，在堆上分配，底层是数组
>
> ​	2倍增长容量：如果没有超过容量插入在后面，没了：将元空间的元素通过复制的方式初始化新空间，在向	新空间插入元素，释放原空间。
>
> ​	在最后插入O(1),在中间插入有内存拷贝，容量不够需要申请+释放 数据拷贝
>
> ​	删除最后很快，中间删除内存拷贝，随机访问，基本不非尾删除
>
> ##### list:
>
> ​	动态链表，在堆上分配，每次插入就会分配，删除元素释放， 底层双向链表
>
> ​	快速访问头尾，不支持随机访问
>
> ​	插入、删除：很快一般都是常数开销
>
> ##### 区别:
>
> 1. ​	vector数组，list双向链表
> 2. vector顺序内存，list不是
> 3. vector中间插入删除内存拷贝，list不会
> 4. vector一次分配内存不够2倍，list插入一个分配一个删除一个释放一个
> 5. vector随机访问，但删除插入慢，list不支持随机访问，但是插入、删除快
>
> ##### 应用场景:
>
> vector：需要高效的随机访问，而不在乎插入删除
>
> list：需要高效的插入删除，不关心随机访问

### 单例模式

> #### 懒汉式
>
> ```CPP
> class danli
> {
> private:
>     danli(){};
>     static danli *a_;
> public:
>     static danli* get()
>     {
>         if(a_ == NULL)
>             a_ = new danli;
>         return a_;
>     }
> };
> ```
>
> #### 饿汉式
>
> ```cpp
> class danli
> {
> private:
>     danli(){};
>     static danli a_;
> public:
>     static danli* get()
>     {
>         return &a_;
>     }
> };
> ```
>
> 

### 大端和小端

> 小端：就是地位字节放在地位地址，高位放在内端的高地址
>
> 大端：高位放在低地址，地位放在高地址
>
> ```CPP
> //区分大小端
> bool fun()
> {
>     union num{
>         int a;
>         char b; // 如果是大端 b就是高位，小端就是地位
>     }num;
>     num.a = 0x1234;
>     if(num.b == 0x12) 
>     {
>         return true;// 大端
>     }
>     return false;//小端
> }
> ```
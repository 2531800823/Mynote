### Vue的基本原理

> 创建实例时，遍历 data 用 **Object.defineProperty()** （vue3 使用 proxy）将他们转为 getter/setter，并且在内部跟踪，每个组件实例都有 watcher 程序， 属性发生变化时，会通知 watcher 重新计算，然后更新组件

### 双向数据绑定

> vue 是采用 **数据劫持** + **发布者-订阅制模式**  的方式，通过 **Object.defineProperty** 来劫持 所有属性的 setter/getter , 在数据有变化，发布消息给订阅制，触发响应的 事件监听（watcher）回调。

### 使用 Object.defineProperty 的缺点

> 通过下标方式修改数组数据，或者给对象增加属性，不可以触发渲染，因为Object.defineProperty 拦截不到这些操作， 大部分的数组都拦截不到， vue 内部通过重写函数的方式 解决了，数组改数据 ：push，pop，shift，unshift，splice，sort，reverse
>
> vue3  抛弃了，使用 proxy 对对象进行代理， 实现数据劫持，使用 proxy的 好处，可以完美监听数据的改变，并可以深度的监听数据， 唯一的缺点就是 兼容问题：**Proxy**是Es6 语法

### MVC  

> 1.  mvc 通过 model , view 和 controller 的方式组织代码结构，view负责页面显示，model负责存储业务数据和相应数据操作，并且view和model 使用了观察者模式
> 2. 当 model 改变时 通知 有关 view 更新页面，controller 是view 和 model的纽带，通过  view 来 对 model 更改，然后 model 再去通知 view 更新，过程都是单向的

### MVVM

> 1. model 代表数据模型，view 代表UI视图， view,model 负责 监听model的变化控制视图，视图变化 通知数据， 
> 2. view 和 model 没有关系，是通过viewmodel 来进行练习的

### MVP

> 1. 和 MVC 唯一不同的 在于 Presenter 和 Controller ，MVC在model 发生变化的时候，通知 view ，view 和 model 偶合在一起，逻辑复杂的时候，代码可能造成混乱，并对复用造成一些问题
> 2. MVP 通过 Presenter 来实现对 view 来实现，model 的解耦，MVC 中Controller 只知道 model 的接口， 没办法控制 view 的更新，MVP 可以通过 View 暴露给 Presenter,将model 和 view 绑定到一起，实现 view 和 model 的同步更新

### Computed 和 Watch

> computed 
>
> 1. 支持缓存，依赖的数据发生变化才会重新计算
> 2. 不支持异步，当有计算属性的时候，无法监听数据变化
> 3. 默认走缓存，基于依赖的响应式进行缓存，或者 父组件传递过来的props 的数据进行计算
> 4. 可以使用 getter 和 setter 方法更灵活
>
> watch 
>
> 1. 不支持缓存，数据变化 会触发响应的操作
> 2. 支持异步监听，两个参数，一个是最新的值，第二个是旧值
> 3. 当一个属性发生变化就做像一个的操作
> 4. immediate: 立即监视， deep : 深度监视 ， handle: 监听函数
>
> 使用场景：
>
> 	1.   计算 当进行计算，可以依赖缓存特性，避免每次都要计算
>  	2.   当需要数据变化时 执行异步，或者 开销较大时，使用 watch , 限制执行该操作的频率，得到最终结果前，设置中间状态（防抖），计算属性不行

### slot

> 是 vue 内容分发机制，插槽是子组件的一个模板标签  ，这个标签由父组件决定，有默认插槽，具名插槽和作用域插槽
>
> 1. 默认： 匿名插槽，没有 slot  name 属性值的时候显示 默认的，一个组件只能有一个匿名
> 2. 具名：带有名字的插槽，可以有多个
> 3. 作用域: 可以有名字也可以无，不同点，在子组件渲染时，可以将子组件内部的数据传递给父组件，父组件根据子组件的数据决定如何渲染

### 保存页面（组件）当前状态

> 两种情况。组件会被卸载 和不会被卸载
>
> ###### 卸载
>
> 1. 将状态存在：LocalStorage / sessiconStorage,卸载组件 就在 beforeDestroy 存进去，进入页面的时候加一个  flag 判断是否用缓存数据，
>    - 优点：兼容好，不用库，简单，
>    - 缺点：JSON转字符串 是深拷贝，function 不会保存，Date,和正则 不是原来的值，flag不好控制，容易失效
> 2. 路由传值：通过路由传参，可以实现简单的路由传值  
>    - 优点：简单，不污染localstorage... 可以传递Date正则（弥补上面） 
>    - 缺点：跳转别的组件也带着数据
>
> ###### 不被卸载
>
> 1. 要切换的组件是子组件，父组件中正常存储页面状态 
>    - 优点：代码量少，不需要考虑状态传递的错误
>    - 缺点： 增加 父组件的维护成本 、 需要传递prop  到子组件， 无法利用理由定位页面
> 2. 可以用  <keep-alive> 来缓存页面 组件在切换 调用 **activated** 和 **deactivated** 声明周期函数

### keep-alive 动态组件 缓存

> ##### 参数:
>
> - include    字符或正则，只有匹配到的缓存 - 白名单
> - exclude    字符 | 正则 ， 匹配到的不缓存 -  黑名单
> - max        number  可以缓存多少

```vue
<!-- 基本 --> 
<transition>
    <keep-alive>
<!-- 缓存 + 动态  可以 if 判断 + transiton(动画) 一起-->
      <component :is="view"></component>   
    </keep-alive>
</transition>
```

### 常用的事件修饰符

> 1.   **.stop** ==> **event.stopPropagation()**   **阻止事件冒泡**
> 2.  **.prevent**   ==>  **event.preventDefault()**  取消默认事件，不停止传播
> 3. **.capture**     ==>  事件捕获
> 4. **.self**    ==>   只触发自己范围内的事件， 不包含子元素
> 5.  **.once**  ==> 只会触发一次

### v-if、v-show、v-html 

> 1. v-if  懒惰的， 第一次是 false 就不加载，切换时 标签创建销毁， 在虚拟 dom 操作，开销比 v-show 大  原理：生成 VNode 不会生成
> 2. v-show 直接创建 显示和隐藏都是用 css display 来控制的   生成，直接 display:none
> 3. v-html : 先移除节点下的所有节点，在 innerHTML 添加 ， **可能会导致 xss 攻击**，**里面的样式还有使用 /deep/ 穿透**
>    - 使用场景，v-if适合运营条件不打可能改变，v-show 适合频繁切换

### data 为什么不是函数

> 使用多个组件，数据会冲突，主要是隔离作用域，让每个组件都有自己的数据

### LRU 缓存策略

> 在内存中找出 最久没有使用的数据，换新数据 ， LRU 算法根据数据的历史记录进行淘汰，最常见的是一个链表保存数据缓存 ， 详细实现：
>
> - ​	新数据插入到链表头部
> - 每当缓存数据被访问，则数据移到链表头部
> - 链表满了将链表尾部数据丢弃

### $nextTick 

> - 本质是对 js 执行原理  EventLoop 的一个应用，模拟对应的 宏/微  任务的实现，用 js 的异步 来执行  vue 的异步
> - 可以操作 在 DOM 更新数据后的 后续逻辑

### $set  $delete

```js
// 给对象或者数组添加一个响应式数据  
this.$set(obj , name , 'liu');  // 对象
this.$set(arr , 0 , 'liu') // 数组
// 删除一个响应式数据
this.$delete(arr , 0 ) // 数组
this.$delete( obj , name) // 对象
```

### 单页面应用和多页面

> 1. SPA单页面：只有一个主页面，一开始只用加载一次 css,js 相关资源，所有内容都在主页面，对每一个功能都模块化，跳转就是切换组件，只刷新局部资源
> 2. MAP 多页面 ：每个页面必须重复加载 js ,css 资源，多页面跳转，需要整个页面刷新

| 对比项/模式 | SPA                                    | MPA                                 |
| :---------: | -------------------------------------- | ----------------------------------- |
|    体验     | 页面多，体验好，首次加载资源多要过调整 | 页面切换慢，网速慢，体验很差        |
|    资源     | 组件公用资源加载一次                   | 每次都要加载自己的                  |
|    场景     | 不利于 SEO优化 （用 SSR 优化 SEO）     | 使用对 SEO 要求高的应该             |
|    更新     | 相关组件切换  局部更新                 | 整个 HTML切换 重复 http请求         |
|  路由跳转   | hash history                           | 超链接 跳转                         |
|  数据传递   | 各种通讯方式                           | cookie...url参数 缓存方案，接口保存 |
|  相关成本   | 前期开发成本高，易维护                 | 前期开发第，维护麻烦                |

### data 属性改变，视图不会立即渲染

> 是按照一定的策略进行 DOM的更新， 在更新是异步的，只要监听到数据变化，开启一个队列，缓存到事件循环中发生的所有数据更改， 重复触发只放入一个队列，防止重复数据，避免不必要的计算，

### 自定义指令

> 1. 使用场景
>    - 普通 DOM 元素进行底层操作，
>    - 自定义指令用来操作 DOM 可以定义任何 DOM 操作，并且可以复用
> 2. 使用案例
>    - 鼠标聚焦
>    - 图片加载错误问题，懒加载

### 子组件可以修改父组件的数据吗

> 不可以直接修改，因为 vue 是单项数据流，，直接赋值操作，会破坏数据流，可以通过 **$emit** 派发一个自定义事件，父组件收到后，父组件自己修改







